{
	"entities": [
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "venkatagroup",
				"name": "venkatawtest",
				"description": "string",
				"compatibility": "NONE",
				"validationLevel": "LATEST",
				"evolve": false
			},
			"id": 73,
			"timestamp": 1531323863672,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 73,
						"name": "MASTER",
						"schemaMetadataName": "venkatawtest",
						"description": "'MASTER' branch for schema metadata 'venkatawtest'",
						"timestamp": 1531323863674
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 477,
							"schemaMetadataId": 73,
							"name": "venkatawtest",
							"description": "ver2",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"JournalKey\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Key Schema.\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"TradingArea\"}],\"root\":\"true\"}",
							"timestamp": 1531326236715,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "MaturityEvent",
				"description": "Maturity Event Schema.",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 69,
			"timestamp": 1530039432135,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 69,
						"name": "MASTER",
						"schemaMetadataName": "MaturityEvent",
						"description": "'MASTER' branch for schema metadata 'MaturityEvent'",
						"timestamp": 1530039432136
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 431,
							"schemaMetadataId": 69,
							"name": "MaturityEvent",
							"description": "Maturity Event Schema.",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"MaturityEvent\",\"namespace\":\"firm.journal\",\"doc\":\"Maturity Event Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID.\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"ID. Generated by maturity event system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"null\",\"string\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"eventState\",\"type\":{\"type\":\"enum\",\"name\":\"EventState\",\"doc\":\"Event State.\",\"symbols\":[\"NEW\",\"CANCEL\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, CANCEL\"}],\"root\":\"true\"}",
							"timestamp": 1530276584301,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODFXForwardRate",
				"description": "EOD FX Forward Rate",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 68,
			"timestamp": 1530039420960,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 68,
						"name": "MASTER",
						"schemaMetadataName": "EODFXForwardRate",
						"description": "'MASTER' branch for schema metadata 'EODFXForwardRate'",
						"timestamp": 1530039420961
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 391,
							"schemaMetadataId": 68,
							"name": "EODFXForwardRate",
							"description": "EOD FX Forward Rate",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODFXForwardRate\",\"namespace\":\"firm.journal\",\"doc\":\"EOD FX Forward Rate\",\"fields\":[{\"name\":\"forwardCurrency\",\"type\":\"string\",\"doc\":\"Forward Currency\"},{\"name\":\"effectiveDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"EffectiveDate. Business date. Input from Event data\"},{\"name\":\"forwardDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"ForwardDate. Input from Event data\"},{\"name\":\"forwardRate\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Forward. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276551910,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "kafka",
				"name": "HwxAvroTest2",
				"description": "Schema registered by KafkaAvroSerializer for topic: [HwxAvroTest2] iskey: [false]",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 67,
			"timestamp": 1529699157882,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 67,
						"name": "MASTER",
						"schemaMetadataName": "HwxAvroTest2",
						"description": "'MASTER' branch for schema metadata 'HwxAvroTest2'",
						"timestamp": 1529699157883
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 110,
							"schemaMetadataId": 67,
							"name": "HwxAvroTest2",
							"description": "Schema registered by serializer:class com.hortonworks.registries.schemaregistry.serdes.avro.AvroSnapshotSerializer",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"yelp_reviews\",\"namespace\":\"com.hortonworks.registries\",\"fields\":[{\"name\":\"user_id\",\"type\":\"string\"},{\"name\":\"review_id\",\"type\":\"string\"},{\"name\":\"stars\",\"type\":\"int\"},{\"name\":\"date\",\"type\":\"string\"},{\"name\":\"business_id\",\"type\":\"string\"},{\"name\":\"type\",\"type\":\"string\"},{\"name\":\"votes\",\"type\":{\"type\":\"record\",\"name\":\"votes_entry\",\"fields\":[{\"name\":\"funny\",\"type\":\"int\"},{\"name\":\"useful\",\"type\":\"int\"},{\"name\":\"cool\",\"type\":\"int\"}]}}]}",
							"timestamp": 1529699158609,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "kafka",
				"name": "HwxAvroTest1",
				"description": "Schema registered by KafkaAvroSerializer for topic: [HwxAvroTest1] iskey: [false]",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 66,
			"timestamp": 1529695794758,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 66,
						"name": "MASTER",
						"schemaMetadataName": "HwxAvroTest1",
						"description": "'MASTER' branch for schema metadata 'HwxAvroTest1'",
						"timestamp": 1529695794760
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 109,
							"schemaMetadataId": 66,
							"name": "HwxAvroTest1",
							"description": "Schema registered by serializer:class com.hortonworks.registries.schemaregistry.serdes.avro.AvroSnapshotSerializer",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"yelp_reviews\",\"namespace\":\"com.hortonworks.registries\",\"fields\":[{\"name\":\"user_id\",\"type\":\"string\"},{\"name\":\"review_id\",\"type\":\"string\"},{\"name\":\"stars\",\"type\":\"int\"},{\"name\":\"date\",\"type\":\"string\"},{\"name\":\"business_id\",\"type\":\"string\"},{\"name\":\"type\",\"type\":\"string\"},{\"name\":\"votes\",\"type\":{\"type\":\"record\",\"name\":\"votes_entry\",\"fields\":[{\"name\":\"funny\",\"type\":\"int\"},{\"name\":\"useful\",\"type\":\"int\"},{\"name\":\"cool\",\"type\":\"int\"}]}}]}",
							"timestamp": 1529695795776,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "UnsequencedFX",
				"description": "* Schema for UnsequencedFX",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 65,
			"timestamp": 1529421186155,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 65,
						"name": "MASTER",
						"schemaMetadataName": "UnsequencedFX",
						"description": "'MASTER' branch for schema metadata 'UnsequencedFX'",
						"timestamp": 1529421186155
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 466,
							"schemaMetadataId": 65,
							"name": "UnsequencedFX",
							"description": "* Schema for UnsequencedFX",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"UnsequencedFX\",\"namespace\":\"firm.transaction.unsequenced.fx\",\"doc\":\"* Schema for UnsequencedFX\",\"fields\":[{\"name\":\"enhanced\",\"type\":{\"type\":\"record\",\"name\":\"EnhancedFX\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedFX\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"forwardDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"the forward date for FX forward contract\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayRecievedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"currency1Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency1Amount\"},{\"name\":\"currency2Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency2Amount\"},{\"name\":\"fxCalc\",\"type\":\"string\",\"doc\":\"* value would be M or D\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null}],\"root\":\"true\"},\"doc\":\"Enhanced FX value\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"system clock set by the process at creation of the instance\"},{\"name\":\"unsequencedState\",\"type\":{\"type\":\"enum\",\"name\":\"UnsequencedState\",\"doc\":\"Represent unsequenced state *\",\"symbols\":[\"SEQUENCED\",\"UNSEQUENCED\",\"UNLOCKED\",\"IGNORED\"]},\"doc\":\"unsequenced event state\"},{\"name\":\"user\",\"type\":[\"string\",\"null\"],\"doc\":\"user id\"},{\"name\":\"enhancedOffset\",\"type\":\"long\",\"doc\":\"offset from the original enhanced topic message\"}],\"root\":\"true\"}",
							"timestamp": 1530276613868,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "UnsequencedEquity",
				"description": "* Schema for UnsequencedFX",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 64,
			"timestamp": 1529421185944,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 64,
						"name": "MASTER",
						"schemaMetadataName": "UnsequencedEquity",
						"description": "'MASTER' branch for schema metadata 'UnsequencedEquity'",
						"timestamp": 1529421185945
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 465,
							"schemaMetadataId": 64,
							"name": "UnsequencedEquity",
							"description": "* Schema for UnsequencedFX",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"UnsequencedEquity\",\"namespace\":\"firm.transaction.unsequenced.equity\",\"doc\":\"* Schema for UnsequencedFX\",\"fields\":[{\"name\":\"enhanced\",\"type\":{\"type\":\"record\",\"name\":\"EnhancedEquity\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedEquity\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayReceivedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc.\r\n\t\t * the key represents the type of the charge\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"* divider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"}],\"root\":\"true\"},\"doc\":\"Enhanced Equity value\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"system clock set by the process at creation of the instance\"},{\"name\":\"unsequencedState\",\"type\":{\"type\":\"enum\",\"name\":\"UnsequencedState\",\"doc\":\"Represent unsequenced state *\",\"symbols\":[\"SEQUENCED\",\"UNSEQUENCED\",\"UNLOCKED\",\"IGNORED\"]},\"doc\":\"unsequenced event state\"},{\"name\":\"user\",\"type\":[\"string\",\"null\"],\"doc\":\"user id\"},{\"name\":\"enhancedOffset\",\"type\":\"long\",\"doc\":\"offset from the original enhanced topic message\"}],\"root\":\"true\"}",
							"timestamp": 1530276612623,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "TransactionKey",
				"description": "The key which uniquely identifies transaction",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 63,
			"timestamp": 1529421185787,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 63,
						"name": "MASTER",
						"schemaMetadataName": "TransactionKey",
						"description": "'MASTER' branch for schema metadata 'TransactionKey'",
						"timestamp": 1529421185787
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 464,
							"schemaMetadataId": 63,
							"name": "TransactionKey",
							"description": "The key which uniquely identifies transaction",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionKey\",\"namespace\":\"firm.transaction.versioned\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"transaction source\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"transaction id\"},{\"name\":\"transactionDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"transaction date (the date when transaction was generated\"},{\"name\":\"version\",\"type\":\"int\",\"doc\":\"transaction version\"}],\"root\":\"true\"}",
							"timestamp": 1530276612103,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "TransactionFX",
				"description": "The key which uniquely identifies transaction",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 62,
			"timestamp": 1529421184975,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 62,
						"name": "MASTER",
						"schemaMetadataName": "TransactionFX",
						"description": "'MASTER' branch for schema metadata 'TransactionFX'",
						"timestamp": 1529421184976
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 463,
							"schemaMetadataId": 62,
							"name": "TransactionFX",
							"description": "The key which uniquely identifies transaction",
							"version": 4,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionFX\",\"namespace\":\"firm.transaction.versioned.fx\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"priorVersion\",\"type\":[\"null\",\"int\"],\"doc\":\"prior version of transaction\"},{\"name\":\"prior\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"EnhancedFX\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedFX\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"forwardDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"the forward date for FX forward contract\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayRecievedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"currency1Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency1Amount\"},{\"name\":\"currency2Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency2Amount\"},{\"name\":\"fxCalc\",\"type\":\"string\",\"doc\":\"* value would be M or D\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null},{\"name\":\"transactionId\",\"type\":[\"null\",\"string\"],\"doc\":\"transaction id\",\"default\":null}],\"root\":\"true\"}],\"doc\":\"prior enhanced record\"},{\"name\":\"current\",\"type\":\"firm.transaction.enhanced.EnhancedFX\",\"doc\":\"current enhanced record\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"transaction knowledge time\",\"default\":null},{\"name\":\"sequencedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"sequenced knowledge time\",\"default\":null},{\"name\":\"sequencedOffset\",\"type\":\"long\",\"doc\":\"offset from the original sequenced topic message\"},{\"name\":\"panoramaTimestamp\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama timestamp to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"panoramaInstrumentId\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama instrument id to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276611065,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 462,
							"schemaMetadataId": 62,
							"name": "TransactionFX",
							"description": "The key which uniquely identifies transaction",
							"version": 3,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionFX\",\"namespace\":\"firm.transaction.versioned.fx\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"priorVersion\",\"type\":[\"null\",\"int\"],\"doc\":\"prior version of transaction\"},{\"name\":\"prior\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"EnhancedFX\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedFX\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"forwardDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"the forward date for FX forward contract\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayRecievedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"currency1Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency1Amount\"},{\"name\":\"currency2Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency2Amount\"},{\"name\":\"fxCalc\",\"type\":\"string\",\"doc\":\"* value would be M or D\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null}],\"root\":\"true\"}],\"doc\":\"prior enhanced record\"},{\"name\":\"current\",\"type\":\"firm.transaction.enhanced.EnhancedFX\",\"doc\":\"current enhanced record\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"transaction knowledge time\",\"default\":null},{\"name\":\"sequencedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"sequenced knowledge time\",\"default\":null},{\"name\":\"sequencedOffset\",\"type\":\"long\",\"doc\":\"offset from the original sequenced topic message\"},{\"name\":\"panoramaTimestamp\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama timestamp to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"panoramaInstrumentId\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama instrument id to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276610865,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 461,
							"schemaMetadataId": 62,
							"name": "TransactionFX",
							"description": "The key which uniquely identifies transaction",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionFX\",\"namespace\":\"firm.transaction.versioned.fx\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"priorVersion\",\"type\":[\"null\",\"int\"],\"doc\":\"prior version of transaction\"},{\"name\":\"prior\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"EnhancedFX\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedFX\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"forwardDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"the forward date for FX forward contract\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayRecievedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"currency1Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency1Amount\"},{\"name\":\"currency2Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency2Amount\"},{\"name\":\"fxCalc\",\"type\":\"string\",\"doc\":\"* value would be M or D\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null}],\"root\":\"true\"}],\"doc\":\"prior enhanced record\"},{\"name\":\"current\",\"type\":\"firm.transaction.enhanced.EnhancedFX\",\"doc\":\"current enhanced record\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"transaction knowledge time\",\"default\":null},{\"name\":\"sequencedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"sequenced knowledge time\",\"default\":null},{\"name\":\"sequencedOffset\",\"type\":\"long\",\"doc\":\"offset from the original sequenced topic message\"},{\"name\":\"panoramaTimestamp\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama timestamp to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"panoramaInstrumentId\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama instrument id to accommodate smooth transition from panorama to new structure\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276610108,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 460,
							"schemaMetadataId": 62,
							"name": "TransactionFX",
							"description": "The key which uniquely identifies transaction",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionFX\",\"namespace\":\"firm.transaction.versioned.fx\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"priorVersion\",\"type\":[\"null\",\"int\"],\"doc\":\"prior version of transaction\"},{\"name\":\"prior\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"EnhancedFX\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedFX\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"forwardDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"the forward date for FX forward contract\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayRecievedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"currency1Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency1Amount\"},{\"name\":\"currency2Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency2Amount\"},{\"name\":\"fxCalc\",\"type\":\"string\",\"doc\":\"* value would be M or D\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null}],\"root\":\"true\"}],\"doc\":\"prior enhanced record\"},{\"name\":\"current\",\"type\":\"firm.transaction.enhanced.EnhancedFX\",\"doc\":\"current enhanced record\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"transaction knowledge time\",\"default\":null},{\"name\":\"sequencedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"sequenced knowledge time\",\"default\":null},{\"name\":\"sequencedOffset\",\"type\":\"long\",\"doc\":\"offset from the original sequenced topic message\"}],\"root\":\"true\"}",
							"timestamp": 1530276609512,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "TransactionEquity",
				"description": "The key which uniquely identifies transaction",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 61,
			"timestamp": 1529421184118,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 61,
						"name": "MASTER",
						"schemaMetadataName": "TransactionEquity",
						"description": "'MASTER' branch for schema metadata 'TransactionEquity'",
						"timestamp": 1529421184118
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 459,
							"schemaMetadataId": 61,
							"name": "TransactionEquity",
							"description": "The key which uniquely identifies transaction",
							"version": 4,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionEquity\",\"namespace\":\"firm.transaction.versioned.equity\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"priorVersion\",\"type\":[\"null\",\"int\"],\"doc\":\"prior version of transaction\"},{\"name\":\"prior\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"EnhancedEquity\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedEquity\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayReceivedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc.\r\n\t\t * the key represents the type of the charge\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"* divider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"},{\"name\":\"transactionId\",\"type\":[\"null\",\"string\"],\"doc\":\"transaction id\",\"default\":null}],\"root\":\"true\"}],\"doc\":\"prior enhanced equity record\"},{\"name\":\"current\",\"type\":\"firm.transaction.enhanced.EnhancedEquity\",\"doc\":\"current enhanced equity record\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"transaction knowledge time\",\"default\":null},{\"name\":\"sequencedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"sequenced knowledge time\",\"default\":null},{\"name\":\"sequencedOffset\",\"type\":\"long\",\"doc\":\"offset from the original sequenced topic message\"},{\"name\":\"panoramaTimestamp\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama timestamp to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"panoramaInstrumentId\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama instrument id to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276609010,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 458,
							"schemaMetadataId": 61,
							"name": "TransactionEquity",
							"description": "The key which uniquely identifies transaction",
							"version": 3,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionEquity\",\"namespace\":\"firm.transaction.versioned.equity\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"priorVersion\",\"type\":[\"null\",\"int\"],\"doc\":\"prior version of transaction\"},{\"name\":\"prior\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"EnhancedEquity\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedEquity\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayReceivedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc.\r\n\t\t * the key represents the type of the charge\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"* divider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"}],\"root\":\"true\"}],\"doc\":\"prior enhanced equity record\"},{\"name\":\"current\",\"type\":\"firm.transaction.enhanced.EnhancedEquity\",\"doc\":\"current enhanced equity record\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"transaction knowledge time\",\"default\":null},{\"name\":\"sequencedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"sequenced knowledge time\",\"default\":null},{\"name\":\"sequencedOffset\",\"type\":\"long\",\"doc\":\"offset from the original sequenced topic message\"},{\"name\":\"panoramaTimestamp\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama timestamp to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"panoramaInstrumentId\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama instrument id to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276608246,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 457,
							"schemaMetadataId": 61,
							"name": "TransactionEquity",
							"description": "The key which uniquely identifies transaction",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionEquity\",\"namespace\":\"firm.transaction.versioned.equity\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"priorVersion\",\"type\":[\"null\",\"int\"],\"doc\":\"prior version of transaction\"},{\"name\":\"prior\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"EnhancedEquity\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedEquity\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayReceivedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc.\r\n\t\t * the key represents the type of the charge\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"* divider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"}],\"root\":\"true\"}],\"doc\":\"prior enhanced equity record\"},{\"name\":\"current\",\"type\":\"firm.transaction.enhanced.EnhancedEquity\",\"doc\":\"current enhanced equity record\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"transaction knowledge time\",\"default\":null},{\"name\":\"sequencedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"sequenced knowledge time\",\"default\":null},{\"name\":\"sequencedOffset\",\"type\":\"long\",\"doc\":\"offset from the original sequenced topic message\"},{\"name\":\"panoramaTimestamp\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama timestamp to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"panoramaInstrumentId\",\"type\":[\"null\",\"long\"],\"doc\":\"legacy panorama instrument id to accommodate smooth transition from panorama to new structure\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276608016,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 456,
							"schemaMetadataId": 61,
							"name": "TransactionEquity",
							"description": "The key which uniquely identifies transaction",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"TransactionEquity\",\"namespace\":\"firm.transaction.versioned.equity\",\"doc\":\"The key which uniquely identifies transaction\",\"fields\":[{\"name\":\"priorVersion\",\"type\":[\"null\",\"int\"],\"doc\":\"prior version of transaction\"},{\"name\":\"prior\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"EnhancedEquity\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedEquity\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayReceivedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc.\r\n\t\t * the key represents the type of the charge\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"* divider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"}],\"root\":\"true\"}],\"doc\":\"prior enhanced equity record\"},{\"name\":\"current\",\"type\":\"firm.transaction.enhanced.EnhancedEquity\",\"doc\":\"current enhanced equity record\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"transaction knowledge time\",\"default\":null},{\"name\":\"sequencedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"sequenced knowledge time\",\"default\":null},{\"name\":\"sequencedOffset\",\"type\":\"long\",\"doc\":\"offset from the original sequenced topic message\"}],\"root\":\"true\"}",
							"timestamp": 1530276607671,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "TradingBookByCode",
				"description": "TradingBook Lookup Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 60,
			"timestamp": 1529421183955,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 60,
						"name": "MASTER",
						"schemaMetadataName": "TradingBookByCode",
						"description": "'MASTER' branch for schema metadata 'TradingBookByCode'",
						"timestamp": 1529421183956
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 455,
							"schemaMetadataId": 60,
							"name": "TradingBookByCode",
							"description": "TradingBook Lookup Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"TradingBookByCode\",\"namespace\":\"firm.book\",\"doc\":\"TradingBook Lookup Stream\",\"fields\":[{\"name\":\"code\",\"type\":\"string\",\"doc\":\"book code\"},{\"name\":\"idHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"EffectiveString\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"value\",\"type\":[\"string\",\"null\"]}],\"logicalType\":\"EffectiveString\"}},\"doc\":\"id history\"}],\"root\":\"true\"}",
							"timestamp": 1530276606227,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "TradingBookAttributes",
				"description": "TradingBook Attributes Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 59,
			"timestamp": 1529421183795,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 59,
						"name": "MASTER",
						"schemaMetadataName": "TradingBookAttributes",
						"description": "'MASTER' branch for schema metadata 'TradingBookAttributes'",
						"timestamp": 1529421183796
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 454,
							"schemaMetadataId": 59,
							"name": "TradingBookAttributes",
							"description": "TradingBook Attributes Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"TradingBookAttributes\",\"namespace\":\"firm.book\",\"doc\":\"TradingBook Attributes Stream\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"book id\"},{\"name\":\"attributesHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"AttributeString\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"code\",\"type\":\"string\"},{\"name\":\"legalEntity\",\"type\":\"string\"},{\"name\":\"currency\",\"type\":\"string\"}],\"logicalType\":\"AttributeString\"}},\"doc\":\"Attributes\"}],\"root\":\"true\"}",
							"timestamp": 1530276605182,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "TradingBook",
				"description": "TradingBook State Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 58,
			"timestamp": 1529421183630,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 58,
						"name": "MASTER",
						"schemaMetadataName": "TradingBook",
						"description": "'MASTER' branch for schema metadata 'TradingBook'",
						"timestamp": 1529421183631
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 453,
							"schemaMetadataId": 58,
							"name": "TradingBook",
							"description": "TradingBook State Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"TradingBook\",\"namespace\":\"firm.book\",\"doc\":\"TradingBook State Stream\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"book id\"},{\"name\":\"codeHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"EffectiveString\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"value\",\"type\":[\"string\",\"null\"]}],\"logicalType\":\"EffectiveString\"}},\"doc\":\"code history\"},{\"name\":\"descriptionHistory\",\"type\":{\"type\":\"array\",\"items\":\"firm.type.EffectiveString\"},\"doc\":\"description history\"}],\"root\":\"true\"}",
							"timestamp": 1530276603179,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "SequencedFX",
				"description": "* Schema for SequencedFX",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 57,
			"timestamp": 1529421183416,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 57,
						"name": "MASTER",
						"schemaMetadataName": "SequencedFX",
						"description": "'MASTER' branch for schema metadata 'SequencedFX'",
						"timestamp": 1529421183417
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 451,
							"schemaMetadataId": 57,
							"name": "SequencedFX",
							"description": "* Schema for SequencedFX",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"SequencedFX\",\"namespace\":\"firm.transaction.sequenced.fx\",\"doc\":\"* Schema for SequencedFX\",\"fields\":[{\"name\":\"enhanced\",\"type\":{\"type\":\"record\",\"name\":\"EnhancedFX\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedFX\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"forwardDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"the forward date for FX forward contract\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayRecievedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"currency1Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency1Amount\"},{\"name\":\"currency2Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency2Amount\"},{\"name\":\"fxCalc\",\"type\":\"string\",\"doc\":\"* value would be M or D\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null}],\"root\":\"true\"},\"doc\":\"Enhanced FX value\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"system clock set by the process at creation of the instance\"},{\"name\":\"enhancedOffset\",\"type\":\"long\",\"doc\":\"offset from the original enhanced topic message\"}],\"root\":\"true\"}",
							"timestamp": 1530276601272,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "SequencedEquity",
				"description": "* Schema for SequencedEquity",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 56,
			"timestamp": 1529421183209,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 56,
						"name": "MASTER",
						"schemaMetadataName": "SequencedEquity",
						"description": "'MASTER' branch for schema metadata 'SequencedEquity'",
						"timestamp": 1529421183209
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 450,
							"schemaMetadataId": 56,
							"name": "SequencedEquity",
							"description": "* Schema for SequencedEquity",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"SequencedEquity\",\"namespace\":\"firm.transaction.sequenced.equity\",\"doc\":\"* Schema for SequencedEquity\",\"fields\":[{\"name\":\"enhanced\",\"type\":{\"type\":\"record\",\"name\":\"EnhancedEquity\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedEquity\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayReceivedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc.\r\n\t\t * the key represents the type of the charge\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"* divider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"}],\"root\":\"true\"},\"doc\":\"Enhanced Equity value\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"system clock set by the process at creation of the instance\"},{\"name\":\"enhancedOffset\",\"type\":\"long\",\"doc\":\"offset from the original enhanced topic message\"}],\"root\":\"true\"}",
							"timestamp": 1530276600167,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "SecurityInfoKey",
				"description": "The key that represents the SecurityInfo",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 55,
			"timestamp": 1529421183058,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 55,
						"name": "MASTER",
						"schemaMetadataName": "SecurityInfoKey",
						"description": "'MASTER' branch for schema metadata 'SecurityInfoKey'",
						"timestamp": 1529421183059
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 449,
							"schemaMetadataId": 55,
							"name": "SecurityInfoKey",
							"description": "The key that represents the SecurityInfo",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"SecurityInfoKey\",\"namespace\":\"firm.securitymaster.firm.output\",\"doc\":\"The key that represents the SecurityInfo\",\"fields\":[{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Globally unique Security Identifier\"}],\"root\":\"true\"}",
							"timestamp": 1530276599356,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "SecurityInfo",
				"description": "* Security Info needed for transaction processing and aggregation",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 54,
			"timestamp": 1529421182872,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 54,
						"name": "MASTER",
						"schemaMetadataName": "SecurityInfo",
						"description": "'MASTER' branch for schema metadata 'SecurityInfo'",
						"timestamp": 1529421182872
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 448,
							"schemaMetadataId": 54,
							"name": "SecurityInfo",
							"description": "* Security Info needed for transaction processing and aggregation",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"SecurityInfo\",\"namespace\":\"firm.securitymaster.output\",\"doc\":\"* Security Info needed for transaction processing and aggregation\",\"fields\":[{\"name\":\"positionId\",\"type\":[\"string\",\"null\"],\"doc\":\"* PositionID from the legacy system\"},{\"name\":\"investmentTypeLegacy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Investment Type identifier from the legacy system ( EFt, EOp, EFO, Bnd, Equ, FX)\"},{\"name\":\"investmentType\",\"type\":\"string\",\"doc\":\"* InvestmentType identifier mapped from Beacon reference data (Equity, Equity Option, Future, Future Option, FX and Bond)\"},{\"name\":\"RIC\",\"type\":[\"string\",\"null\"],\"doc\":\"* The Reuters instrument code\"},{\"name\":\"pricingRIC\",\"type\":[\"string\",\"null\"],\"doc\":\"* The RIC used for pricing\"},{\"name\":\"ticker\",\"type\":[\"string\",\"null\"],\"doc\":\"* Ticker for the security\"},{\"name\":\"CUSIP\",\"type\":[\"string\",\"null\"],\"doc\":\"* The CUSIP for the security\"},{\"name\":\"ISIN\",\"type\":[\"string\",\"null\"],\"doc\":\"* The ISIN for the security\"},{\"name\":\"SEDOL\",\"type\":[\"string\",\"null\"],\"doc\":\"* The SEDOL for the security\"},{\"name\":\"executionBrokerSymbol\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"* This is a list of all the variations of the security we can get from different broker.\"},{\"name\":\"countryOfRegisterLegacy\",\"type\":[\"string\",\"null\"],\"doc\":\"* The CountryOfRegister for the security from the legacy system.\"},{\"name\":\"countryOfRegister\",\"type\":\"string\",\"doc\":\"* The CountryOfRegister for the security.\"},{\"name\":\"countryOfIncLegacy\",\"type\":[\"string\",\"null\"],\"doc\":\"* The CountryOfInc for the security from the legacy system\"},{\"name\":\"countryOfInc\",\"type\":\"string\",\"doc\":\"* The CountryOfInc for the security.\"},{\"name\":\"panoExchangeId\",\"type\":[\"string\",\"null\"],\"doc\":\"* The PanoExchange for the security from the legacy system.\"},{\"name\":\"masterExchange\",\"type\":[\"string\",\"null\"],\"doc\":\"* The MasterExchange for the security from the legacy system.\"},{\"name\":\"exchangeId\",\"type\":\"string\",\"doc\":\"* The exchangeId for the security. This is the firmID for the exchange.\"},{\"name\":\"isSwap\",\"type\":[\"boolean\",\"null\"],\"doc\":\"* The isSwap flag for the security.\"},{\"name\":\"bloombergCode\",\"type\":[\"string\",\"null\"],\"doc\":\"* For Futures, first two characters of Future Code\"},{\"name\":\"bbgSecurityTypeDescription\",\"type\":[\"string\",\"null\"],\"doc\":\"* For Futures, Bloomberg Security Type Description.\"},{\"name\":\"exchangeSymbol\",\"type\":[\"string\",\"null\"],\"doc\":\"* For Futures, ExchangeSymbol.\"},{\"name\":\"currencyLegacy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Position currency\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"* Firm Id for the Position currency\"},{\"name\":\"strike\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"* Option strike (mandatory for Options)\"},{\"name\":\"putOrCall\",\"type\":[\"string\",\"null\"],\"doc\":\"* Option put or call (mandatory for Options)\"},{\"name\":\"exerciseDate\",\"type\":[{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"null\"],\"doc\":\"* Exercise Date (mandatory for Options)\"},{\"name\":\"maturityDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* MaturityDate (mandatory for Futures)\"},{\"name\":\"fxCurrency1Legacy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Base currency of the FX security (mandatory for FX)\"},{\"name\":\"fxCurrency1\",\"type\":[\"string\",\"null\"],\"doc\":\"* Firm id for the Base currency of the FX security (mandatory for FX)\"},{\"name\":\"fxCurrency2Legacy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Dealt currency of the FX security (mandatory for FX)\"},{\"name\":\"fxCurrency2\",\"type\":[\"string\",\"null\"],\"doc\":\"* Firm id for the Dealt currency of the FX security (mandatory for FX)\"},{\"name\":\"fxForwardDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Forward Date for the FX transaction (mandatory for FX)\"},{\"name\":\"priceFactor\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* Prive factor\"},{\"name\":\"scalingFactor\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* ScalingFactor aka contract size\"},{\"name\":\"underlyingLegacy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Underlying of the Security from the legacy system\"},{\"name\":\"underlying\",\"type\":[\"string\",\"null\"],\"doc\":\"* Underlying of the Security\"},{\"name\":\"effectiveStartDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* The start date from which this entry is valid\"},{\"name\":\"effectiveEndDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* The final date for which this entry is valid\"},{\"name\":\"knowledgeTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* System clock set by the process at creation of the instance\"}],\"root\":\"true\"}",
							"timestamp": 1530276598951,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "RawNeovestValue",
				"description": "\"Value Schema for Raw Neovest messages\"",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 53,
			"timestamp": 1529421182693,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 53,
						"name": "MASTER",
						"schemaMetadataName": "RawNeovestValue",
						"description": "'MASTER' branch for schema metadata 'RawNeovestValue'",
						"timestamp": 1529421182694
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 447,
							"schemaMetadataId": 53,
							"name": "RawNeovestValue",
							"description": "\"Value Schema for Raw Neovest messages\"",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"RawNeovestValue\",\"namespace\":\"firm.transaction.raw.neovest\",\"doc\":\"\\\"Value Schema for Raw Neovest messages\\\"\",\"fields\":[{\"name\":\"messageType\",\"type\":\"string\",\"doc\":\"Type of Neovest message, OE_ORDER_DATA, OE_ALLOCATED_DATA, etc\"},{\"name\":\"gatewayReceivedTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"Date and time when the messages was received by our gateway\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"Data and time when raw Neovest message was created\"},{\"name\":\"seqResetDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"Data and time when the neoSysSeqNum for this gateway was reset. The value will be constant for a given business day\"},{\"name\":\"data\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Data\",\"fields\":[{\"name\":\"fieldName\",\"type\":[\"string\",\"null\"]},{\"name\":\"fieldId\",\"type\":[\"int\",\"null\"]},{\"name\":\"fieldValue\",\"type\":[\"string\",\"null\"]}]}},\"doc\":\"Represents the map of Neovest fieldName to Data. Data contains the fieldId, fieldName and fieldValue\"},{\"name\":\"originalGatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw message originated\r\n        * The original gateway name has some normalization rules associated with it and can be different then key's gatewayName.\"},{\"name\":\"originalSessionId\",\"type\":\"string\",\"doc\":\"The original gateway name has some normalization rules associated with it and can be different then key's gatewayName.\"}],\"root\":\"true\"}",
							"timestamp": 1530276598544,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "RawNeovestKey",
				"description": "This key makes sure that all the Neovest messages from a particular FIX session are always available on the same partition",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 52,
			"timestamp": 1529421182540,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 52,
						"name": "MASTER",
						"schemaMetadataName": "RawNeovestKey",
						"description": "'MASTER' branch for schema metadata 'RawNeovestKey'",
						"timestamp": 1529421182541
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 446,
							"schemaMetadataId": 52,
							"name": "RawNeovestKey",
							"description": "This key makes sure that all the Neovest messages from a particular FIX session are always available on the same partition",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"RawNeovestKey\",\"namespace\":\"firm.transaction.raw.neovest\",\"doc\":\"This key makes sure that all the Neovest messages from a particular FIX session are always available on the same partition\",\"fields\":[{\"name\":\"sendingDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"The dateTime when the messages was sent to us by the broker's fix engine, this is not the time when Neovest is sending us\"},{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw message originated\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"sessionId for messages from Neovest will be in the format SenderCompID++TargetCompID. This is because, a single instance of Neovest can receive messages from session with same sessionId, but different FIX engines. The combination has proved to be unique across FIX engines.\"},{\"name\":\"neoSysSeqNum\",\"type\":\"int\",\"doc\":\"neoSysSeqNum, Neovest generates a sysSeqNum which is sequential for all the messages that it publishes to allobridge user, it doesnot use the FIX MsgSeqNum\"}],\"root\":\"true\"}",
							"timestamp": 1530276598294,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "RawNeovestFilteredValue",
				"description": "\"Value Schema for Raw Neovest messages\"",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 51,
			"timestamp": 1529421182362,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 51,
						"name": "MASTER",
						"schemaMetadataName": "RawNeovestFilteredValue",
						"description": "'MASTER' branch for schema metadata 'RawNeovestFilteredValue'",
						"timestamp": 1529421182363
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 445,
							"schemaMetadataId": 51,
							"name": "RawNeovestFilteredValue",
							"description": "\"Value Schema for Raw Neovest messages\"",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"RawNeovestFilteredValue\",\"namespace\":\"firm.transaction.raw.neovest\",\"doc\":\"\\\"Value Schema for Raw Neovest messages\\\"\",\"fields\":[{\"name\":\"filterDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"Datetime when this filter occurred\"},{\"name\":\"rawNeovestValue\",\"type\":{\"type\":\"record\",\"name\":\"RawNeovestValue\",\"doc\":\"\\\"Value Schema for Raw Neovest messages\\\"\",\"fields\":[{\"name\":\"messageType\",\"type\":\"string\",\"doc\":\"Type of Neovest message, OE_ORDER_DATA, OE_ALLOCATED_DATA, etc\"},{\"name\":\"gatewayReceivedTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"Date and time when the messages was received by our gateway\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"Data and time when raw Neovest message was created\"},{\"name\":\"seqResetDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"Data and time when the neoSysSeqNum for this gateway was reset. The value will be constant for a given business day\"},{\"name\":\"data\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Data\",\"fields\":[{\"name\":\"fieldName\",\"type\":[\"string\",\"null\"]},{\"name\":\"fieldId\",\"type\":[\"int\",\"null\"]},{\"name\":\"fieldValue\",\"type\":[\"string\",\"null\"]}]}},\"doc\":\"Represents the map of Neovest fieldName to Data. Data contains the fieldId, fieldName and fieldValue\"},{\"name\":\"originalGatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw message originated\r\n        * The original gateway name has some normalization rules associated with it and can be different then key's gatewayName.\"},{\"name\":\"originalSessionId\",\"type\":\"string\",\"doc\":\"The original gateway name has some normalization rules associated with it and can be different then key's gatewayName.\"}],\"root\":\"true\"},\"doc\":\"Filtered Raw Neovest Value\"},{\"name\":\"reason\",\"type\":\"string\",\"doc\":\"Reason why this rawNeovestValue was filtered\"}],\"root\":\"true\"}",
							"timestamp": 1530276597491,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "RawNeovestErroredValue",
				"description": "\"Value Schema for Raw Neovest messages\"",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 50,
			"timestamp": 1529421182162,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 50,
						"name": "MASTER",
						"schemaMetadataName": "RawNeovestErroredValue",
						"description": "'MASTER' branch for schema metadata 'RawNeovestErroredValue'",
						"timestamp": 1529421182162
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 444,
							"schemaMetadataId": 50,
							"name": "RawNeovestErroredValue",
							"description": "\"Value Schema for Raw Neovest messages\"",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"RawNeovestErroredValue\",\"namespace\":\"firm.transaction.raw.neovest\",\"doc\":\"\\\"Value Schema for Raw Neovest messages\\\"\",\"fields\":[{\"name\":\"errorDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"Datetime when this error occurred\"},{\"name\":\"rawNeovestValue\",\"type\":{\"type\":\"record\",\"name\":\"RawNeovestValue\",\"doc\":\"\\\"Value Schema for Raw Neovest messages\\\"\",\"fields\":[{\"name\":\"messageType\",\"type\":\"string\",\"doc\":\"Type of Neovest message, OE_ORDER_DATA, OE_ALLOCATED_DATA, etc\"},{\"name\":\"gatewayReceivedTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"Date and time when the messages was received by our gateway\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"Data and time when raw Neovest message was created\"},{\"name\":\"seqResetDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"Data and time when the neoSysSeqNum for this gateway was reset. The value will be constant for a given business day\"},{\"name\":\"data\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Data\",\"fields\":[{\"name\":\"fieldName\",\"type\":[\"string\",\"null\"]},{\"name\":\"fieldId\",\"type\":[\"int\",\"null\"]},{\"name\":\"fieldValue\",\"type\":[\"string\",\"null\"]}]}},\"doc\":\"Represents the map of Neovest fieldName to Data. Data contains the fieldId, fieldName and fieldValue\"},{\"name\":\"originalGatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw message originated\r\n        * The original gateway name has some normalization rules associated with it and can be different then key's gatewayName.\"},{\"name\":\"originalSessionId\",\"type\":\"string\",\"doc\":\"The original gateway name has some normalization rules associated with it and can be different then key's gatewayName.\"}],\"root\":\"true\"},\"doc\":\"Errored Raw Neovest Value\"},{\"name\":\"errorType\",\"type\":\"string\",\"doc\":\"* The common well known identifier associated with error flow\"},{\"name\":\"errorMessage\",\"type\":\"string\",\"doc\":\"Reason why this rawNeovestValue was Errored\"},{\"name\":\"errorTrace\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Trace of the Error\"}],\"root\":\"true\"}",
							"timestamp": 1530276595630,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "RawFIXKey",
				"description": "This key makes sure that all the FIX messages from a particular FIX session are always available on the same partition",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 49,
			"timestamp": 1529421182001,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 49,
						"name": "MASTER",
						"schemaMetadataName": "RawFIXKey",
						"description": "'MASTER' branch for schema metadata 'RawFIXKey'",
						"timestamp": 1529421182002
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 443,
							"schemaMetadataId": 49,
							"name": "RawFIXKey",
							"description": "This key makes sure that all the FIX messages from a particular FIX session are always available on the same partition",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"RawFIXKey\",\"namespace\":\"firm.transaction.raw.fix\",\"doc\":\"This key makes sure that all the FIX messages from a particular FIX session are always available on the same partition\",\"fields\":[{\"name\":\"sendingDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"The date when the messages was sent to us by the broker's fix engine\"},{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw FIX message originated\r\n        There is a possibility that two FIX engines can have the same SessionID configured and this field would\r\n        be the differentiator\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"Identifier for the FIX sessionID.\"},{\"name\":\"msgSeqNum\",\"type\":\"int\",\"doc\":\"MsgSeqNum generated by the FIX engine for his session\"}],\"root\":\"true\"}",
							"timestamp": 1530276594689,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "PMPositionPnL",
				"description": "Position PnL Value Schema.",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 48,
			"timestamp": 1529421181664,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 48,
						"name": "MASTER",
						"schemaMetadataName": "PMPositionPnL",
						"description": "'MASTER' branch for schema metadata 'PMPositionPnL'",
						"timestamp": 1529421181664
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 442,
							"schemaMetadataId": 48,
							"name": "PMPositionPnL",
							"description": "Position PnL Value Schema.",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"PMPositionPnL\",\"namespace\":\"firm.journal\",\"doc\":\"Position PnL Value Schema.\",\"fields\":[{\"name\":\"appliedKnowledgeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"quantity\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"price - {costLocal / quantity}\"},{\"name\":\"fxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"fXRate - {costBook / costLocal}\"},{\"name\":\"costLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"localCost\"},{\"name\":\"costBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"bookCost\"},{\"name\":\"plLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plLocal - {Realized Px Local + Unrealized Px Local}\"},{\"name\":\"plTodayLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plTodayLocal\"},{\"name\":\"plAsOfLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plAsofLocal\"},{\"name\":\"plBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plBook\"},{\"name\":\"plUnrealizedLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plUnrealizedLocal\"},{\"name\":\"plRealizedLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedLocal\"},{\"name\":\"plUnrealizedBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plUnrealizedBook\"},{\"name\":\"plUnrealizedPxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plPLUnrealizedPXBook\"},{\"name\":\"plUnrealizedFxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plUnrealizedFXBook\"},{\"name\":\"plUnrealizedCrossBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plUnrealizedCrossBook\"},{\"name\":\"plRealizedBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedBook\"},{\"name\":\"plRealizedPxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedPxBook\"},{\"name\":\"plRealizedFxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedFxBook\"},{\"name\":\"plRealizedCrossBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedCrossBook\"},{\"name\":\"navLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navLocal\"},{\"name\":\"navBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navBook\"},{\"name\":\"navUnrealizedLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedLocal\"},{\"name\":\"navUnrealizedBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedBook\"},{\"name\":\"navUnrealizedPxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedPXBook\"},{\"name\":\"navUnrealizedFxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedFXBook\"},{\"name\":\"navUnrealizedCrossBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedCrossBook\"},{\"name\":\"maxTopicPartitionMap\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"null\"],\"doc\":\"Map of TopicPartitionOffset\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276592905,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 441,
							"schemaMetadataId": 48,
							"name": "PMPositionPnL",
							"description": "Position PnL Value Schema.",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"PMPositionPnL\",\"namespace\":\"firm.journal\",\"doc\":\"Position PnL Value Schema.\",\"fields\":[{\"name\":\"appliedKnowledgeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"quantity\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"price - {costLocal / quantity}\"},{\"name\":\"fxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"fXRate - {costBook / costLocal}\"},{\"name\":\"costLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"localCost\"},{\"name\":\"costBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"bookCost\"},{\"name\":\"plLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plLocal - {Realized Px Local + Unrealized Px Local}\"},{\"name\":\"plTodayLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plTodayLocal\"},{\"name\":\"plAsOfLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plAsofLocal\"},{\"name\":\"plBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plBook\"},{\"name\":\"plUnrealizedLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plUnrealizedLocal\"},{\"name\":\"plRealizedLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedLocal\"},{\"name\":\"plUnrealizedBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plUnrealizedBook\"},{\"name\":\"plUnrealizedPxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plPLUnrealizedPXBook\"},{\"name\":\"plUnrealizedFxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plUnrealizedFXBook\"},{\"name\":\"plUnrealizedCrossBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plUnrealizedCrossBook\"},{\"name\":\"plRealizedBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedBook\"},{\"name\":\"plRealizedPxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedPxBook\"},{\"name\":\"plRealizedFxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedFxBook\"},{\"name\":\"plRealizedCrossBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"plRealizedCrossBook\"},{\"name\":\"navLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navLocal\"},{\"name\":\"navBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navBook\"},{\"name\":\"navUnrealizedLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedLocal\"},{\"name\":\"navUnrealizedBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedBook\"},{\"name\":\"navUnrealizedPxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedPXBook\"},{\"name\":\"navUnrealizedFxBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedFXBook\"},{\"name\":\"navUnrealizedCrossBook\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"navUnrealizedCrossBook\"},{\"name\":\"maxTopicPartitionMap\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"null\"],\"doc\":\"Map of TopicPartitionOffset\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276592595,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "PMPositionKey",
				"description": "Key to identify PM position",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 47,
			"timestamp": 1529421181507,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 47,
						"name": "MASTER",
						"schemaMetadataName": "PMPositionKey",
						"description": "'MASTER' branch for schema metadata 'PMPositionKey'",
						"timestamp": 1529421181507
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 440,
							"schemaMetadataId": 47,
							"name": "PMPositionKey",
							"description": "Key to identify PM position",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"PMPositionKey\",\"namespace\":\"firm.position\",\"doc\":\"Key to identify PM position\",\"fields\":[{\"name\":\"pmKey\",\"type\":{\"type\":\"record\",\"name\":\"PMKeyRecord\",\"fields\":[{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* Firm's trading account identifier which can be linked to PM, firm accounting structure and etc.\"},{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"Internal firm security id\"},{\"name\":\"strategy\",\"type\":\"string\",\"doc\":\"PM controlled tag to group positions\"},{\"name\":\"positionDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* Position date. Transaction's appliedKnowledgeDate goes into this field\"}],\"type-only\":\"true\"},\"doc\":\"pmKey\"}],\"root\":\"true\"}",
							"timestamp": 1530276591643,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "PMPosition",
				"description": "PM position",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 46,
			"timestamp": 1529421181272,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 46,
						"name": "MASTER",
						"schemaMetadataName": "PMPosition",
						"description": "'MASTER' branch for schema metadata 'PMPosition'",
						"timestamp": 1529421181272
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 439,
							"schemaMetadataId": 46,
							"name": "PMPosition",
							"description": "PM position",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"PMPosition\",\"namespace\":\"firm.position\",\"doc\":\"PM position\",\"fields\":[{\"name\":\"id\",\"type\":[\"string\",\"null\"],\"doc\":\"ID\"},{\"name\":\"uniqueId\",\"type\":[\"string\",\"null\"],\"doc\":\"UniqueId\"},{\"name\":\"pmPositionRecord\",\"type\":{\"type\":\"record\",\"name\":\"PMPositionRecord\",\"fields\":[{\"name\":\"AggregationTimePeriod\",\"type\":\"string\",\"doc\":\"Aggregation time period bucket\",\"default\":null},{\"name\":\"checkpoint\",\"type\":\"string\",\"doc\":\"Checkpoint value on which to synchronize calculations\",\"default\":null},{\"name\":\"quantityOpen\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Number of shares known since last EOD\"},{\"name\":\"cashOpen\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cash hold by PM.\"},{\"name\":\"costOpen\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost associated with acquiring quantity\"},{\"name\":\"quantityBought\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Number of shares bought\"},{\"name\":\"costBought\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost of shares or amount bought\"},{\"name\":\"minDateTimeBought\",\"type\":[{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"null\"],\"doc\":\"Execution time of first buy transaction\"},{\"name\":\"maxDateTimeBought\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"Execution time of last buy transaction\"},{\"name\":\"quantitySold\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Amount of shares bought\"},{\"name\":\"costSold\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Total cost of all sells\"},{\"name\":\"minDateTimeSold\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"Execution time of first sell transaction\"},{\"name\":\"maxDateTimeSold\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"Execution time of last sell transaction\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":\"firm.type.BigDecimal\"},\"null\"],\"doc\":\"Total charge paid for trading. the map of various charges: commission, SEC fee, tax, etc. the key represents the name of the charge\"},{\"name\":\"cash\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Total cash received today\"},{\"name\":\"asOfQuantityBought\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity from all AsOf buy transactions\"},{\"name\":\"asOfCostBought\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost from all AsOf buy transactions\"},{\"name\":\"asOfQuantitySold\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity from all AsOf sell transactions\"},{\"name\":\"asOfCostSold\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost from all AsOf sell transactions\"},{\"name\":\"asOfCharges\",\"type\":[{\"type\":\"map\",\"values\":\"firm.type.BigDecimal\"},\"null\"],\"doc\":\"Charge across all as AsOf transactions\"},{\"name\":\"asOfCash\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cash from all AsOf cash transactions\"},{\"name\":\"quantityCA\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity of shares from corporate actions\"},{\"name\":\"costCA\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost related to corporate actions\"},{\"name\":\"chargesCA\",\"type\":[{\"type\":\"map\",\"values\":\"firm.type.BigDecimal\"},\"null\"],\"doc\":\"Charge across all corp actions\"},{\"name\":\"dividend\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Dividends received today. (could be negative if position was short)\"},{\"name\":\"asOfQuantityCA\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity from all AsOf CA transactions\"},{\"name\":\"asOfCostCA\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost from all AsOf CA transactions\"},{\"name\":\"asOfChargesCA\",\"type\":[{\"type\":\"map\",\"values\":\"firm.type.BigDecimal\"},\"null\"],\"doc\":\"Charge across all As-Of corp actions\"},{\"name\":\"asOfDividend\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cash from all AsOf cash transactions\"}],\"type-only\":\"true\"},\"doc\":\"pmPositionRecord\"}],\"root\":\"true\"}",
							"timestamp": 1530276590277,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "PMPnLKey",
				"description": "Key to identinfy PM PnL",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 45,
			"timestamp": 1529421181108,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 45,
						"name": "MASTER",
						"schemaMetadataName": "PMPnLKey",
						"description": "'MASTER' branch for schema metadata 'PMPnLKey'",
						"timestamp": 1529421181108
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 438,
							"schemaMetadataId": 45,
							"name": "PMPnLKey",
							"description": "Key to identinfy PM PnL",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"PMPnLKey\",\"namespace\":\"firm.pnl\",\"doc\":\"Key to identinfy PM PnL\",\"fields\":[{\"name\":\"pmKey\",\"type\":{\"type\":\"record\",\"name\":\"PMKeyRecord\",\"namespace\":\"firm.position\",\"fields\":[{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* Firm's trading account identifier which can be linked to PM, firm accounting structure and etc.\"},{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"Internal firm security id\"},{\"name\":\"strategy\",\"type\":\"string\",\"doc\":\"PM controlled tag to group positions\"},{\"name\":\"positionDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* Position date. Transaction's appliedKnowledgeDate goes into this field\"}],\"type-only\":\"true\"},\"doc\":\"* pmKey\"}],\"root\":\"true\"}",
							"timestamp": 1530276589480,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "PMPnL",
				"description": "PM PnL Schema.",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 44,
			"timestamp": 1529421180832,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 44,
						"name": "MASTER",
						"schemaMetadataName": "PMPnL",
						"description": "'MASTER' branch for schema metadata 'PMPnL'",
						"timestamp": 1529421180833
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 437,
							"schemaMetadataId": 44,
							"name": "PMPnL",
							"description": "PM PnL Schema.",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"PMPnL\",\"namespace\":\"firm.pnl\",\"doc\":\"PM PnL Schema.\",\"fields\":[{\"name\":\"id\",\"type\":[\"string\",\"null\"],\"doc\":\"* id\"},{\"name\":\"uniqueId\",\"type\":[\"string\",\"null\"],\"doc\":\"* uniqueId\"},{\"name\":\"PMPosition\",\"type\":[{\"type\":\"record\",\"name\":\"PMPositionRecord\",\"namespace\":\"firm.position\",\"fields\":[{\"name\":\"AggregationTimePeriod\",\"type\":\"string\",\"doc\":\"Aggregation time period bucket\",\"default\":null},{\"name\":\"checkpoint\",\"type\":\"string\",\"doc\":\"Checkpoint value on which to synchronize calculations\",\"default\":null},{\"name\":\"quantityOpen\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Number of shares known since last EOD\"},{\"name\":\"cashOpen\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cash hold by PM.\"},{\"name\":\"costOpen\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost associated with acquiring quantity\"},{\"name\":\"quantityBought\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Number of shares bought\"},{\"name\":\"costBought\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost of shares or amount bought\"},{\"name\":\"minDateTimeBought\",\"type\":[{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"null\"],\"doc\":\"Execution time of first buy transaction\"},{\"name\":\"maxDateTimeBought\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"Execution time of last buy transaction\"},{\"name\":\"quantitySold\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Amount of shares bought\"},{\"name\":\"costSold\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Total cost of all sells\"},{\"name\":\"minDateTimeSold\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"Execution time of first sell transaction\"},{\"name\":\"maxDateTimeSold\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"Execution time of last sell transaction\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":\"firm.type.BigDecimal\"},\"null\"],\"doc\":\"Total charge paid for trading. the map of various charges: commission, SEC fee, tax, etc. the key represents the name of the charge\"},{\"name\":\"cash\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Total cash received today\"},{\"name\":\"asOfQuantityBought\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity from all AsOf buy transactions\"},{\"name\":\"asOfCostBought\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost from all AsOf buy transactions\"},{\"name\":\"asOfQuantitySold\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity from all AsOf sell transactions\"},{\"name\":\"asOfCostSold\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost from all AsOf sell transactions\"},{\"name\":\"asOfCharges\",\"type\":[{\"type\":\"map\",\"values\":\"firm.type.BigDecimal\"},\"null\"],\"doc\":\"Charge across all as AsOf transactions\"},{\"name\":\"asOfCash\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cash from all AsOf cash transactions\"},{\"name\":\"quantityCA\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity of shares from corporate actions\"},{\"name\":\"costCA\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost related to corporate actions\"},{\"name\":\"chargesCA\",\"type\":[{\"type\":\"map\",\"values\":\"firm.type.BigDecimal\"},\"null\"],\"doc\":\"Charge across all corp actions\"},{\"name\":\"dividend\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Dividends received today. (could be negative if position was short)\"},{\"name\":\"asOfQuantityCA\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity from all AsOf CA transactions\"},{\"name\":\"asOfCostCA\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cost from all AsOf CA transactions\"},{\"name\":\"asOfChargesCA\",\"type\":[{\"type\":\"map\",\"values\":\"firm.type.BigDecimal\"},\"null\"],\"doc\":\"Charge across all As-Of corp actions\"},{\"name\":\"asOfDividend\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Cash from all AsOf cash transactions\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"*\"},{\"name\":\"AverageTraderCost\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Data from Aggregated position\"},{\"name\":\"AverageHistoricCost\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* AverageHistoricCost\"},{\"name\":\"PLAdjustmentPositionCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"CashRecToday\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"OpeningPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"ClosingPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"OpeningSpotFXRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"ClosingSpotFXRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"MarketPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"UnderlyingPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"TotalPLPortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Total PL\"},{\"name\":\"TotalPLPositionCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"TradingPLPortfolioCcy2\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PL based on today's trades\"},{\"name\":\"TradingPLPositionCcy2\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"PLNewTradeIlAdjPortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PL adjustments in currency of position\"},{\"name\":\"PLAmendedTradeIlAdjPortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PL adjustments in currency of position\"},{\"name\":\"PLAccruedIntPortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PLAccruedInt modified from position currency to USD\"},{\"name\":\"PLRepoIntPortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PL from Repo Interest, reported in USD\"},{\"name\":\"PLAdjustmentPortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PL correction applied in the currency of the position\"},{\"name\":\"PLDividendsPortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Total PL component from dividends in USD\"},{\"name\":\"PLNewTradePortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PL from new trades today\"},{\"name\":\"PLNewTradePositionCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"PLAmendedTradePortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PL due to amendments\"},{\"name\":\"PLAmendedTradePositionCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"PLMVChangePortfolioCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Change in PL due to movement in market price for the opening position\"},{\"name\":\"PLMVChangePositionCcy\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"PnLToday\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"PnLFXDrift\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"*\"},{\"name\":\"Position\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"total quantity\"},{\"name\":\"PLLocal\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"PL in local ccy\"}],\"root\":\"true\"}",
							"timestamp": 1530276588323,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "PMPerspectiveKey",
				"description": "PM Position PnL Key Schema.",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 43,
			"timestamp": 1529421180675,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 43,
						"name": "MASTER",
						"schemaMetadataName": "PMPerspectiveKey",
						"description": "'MASTER' branch for schema metadata 'PMPerspectiveKey'",
						"timestamp": 1529421180676
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 436,
							"schemaMetadataId": 43,
							"name": "PMPerspectiveKey",
							"description": "PM Position PnL Key Schema.",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"PMPerspectiveKey\",\"namespace\":\"firm.journal\",\"doc\":\"PM Position PnL Key Schema.\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"Unique Id.\"}],\"root\":\"true\"}",
							"timestamp": 1530276587531,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "OperationsBrokerByCode",
				"description": "OperationsBroker Lookup Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 42,
			"timestamp": 1529421180508,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 42,
						"name": "MASTER",
						"schemaMetadataName": "OperationsBrokerByCode",
						"description": "'MASTER' branch for schema metadata 'OperationsBrokerByCode'",
						"timestamp": 1529421180508
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 435,
							"schemaMetadataId": 42,
							"name": "OperationsBrokerByCode",
							"description": "OperationsBroker Lookup Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"OperationsBrokerByCode\",\"namespace\":\"firm.counterParty.operationsBroker\",\"doc\":\"OperationsBroker Lookup Stream\",\"fields\":[{\"name\":\"code\",\"type\":\"string\",\"doc\":\"operations broker history\"},{\"name\":\"idHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"EffectiveString\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"value\",\"type\":[\"string\",\"null\"]}],\"logicalType\":\"EffectiveString\"}},\"doc\":\"id history\"}],\"root\":\"true\"}",
							"timestamp": 1530276586995,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "NormalizedKey",
				"description": "Key Schema for normalized messages",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 41,
			"timestamp": 1529421180343,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 41,
						"name": "MASTER",
						"schemaMetadataName": "NormalizedKey",
						"description": "'MASTER' branch for schema metadata 'NormalizedKey'",
						"timestamp": 1529421180344
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 434,
							"schemaMetadataId": 41,
							"name": "NormalizedKey",
							"description": "Key Schema for normalized messages",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"NormalizedKey\",\"namespace\":\"firm.transaction.normalized\",\"doc\":\"Key Schema for normalized messages\",\"fields\":[{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"The name of our gateway which brought the message in\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"The name of the session inside gateway\"},{\"name\":\"seqStartDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"The date when sequence has been started\"},{\"name\":\"seqNum\",\"type\":\"long\",\"doc\":\"Sequence number inside the given seqStartDateTime\"}],\"root\":\"true\"}",
							"timestamp": 1530276586623,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "NormalizedFX",
				"description": "*\"Schema for a FX Spot, Forward and NDF message received from FIX, file, manual entry, etc.\"",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 40,
			"timestamp": 1529421180130,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 40,
						"name": "MASTER",
						"schemaMetadataName": "NormalizedFX",
						"description": "'MASTER' branch for schema metadata 'NormalizedFX'",
						"timestamp": 1529421180131
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 433,
							"schemaMetadataId": 40,
							"name": "NormalizedFX",
							"description": "*\"Schema for a FX Spot, Forward and NDF message received from FIX, file, manual entry, etc.\"",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"NormalizedFX\",\"namespace\":\"firm.transaction.normalized.fx\",\"doc\":\"*\\\"Schema for a FX Spot, Forward and NDF message received from FIX, file, manual entry, etc.\\\"\",\"fields\":[{\"name\":\"rawId\",\"type\":[{\"type\":\"record\",\"name\":\"RawFIXKey\",\"namespace\":\"firm.transaction.raw.fix\",\"doc\":\"This key makes sure that all the FIX messages from a particular FIX session are always available on the same partition\",\"fields\":[{\"name\":\"sendingDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"The date when the messages was sent to us by the broker's fix engine\"},{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw FIX message originated\r\n        There is a possibility that two FIX engines can have the same SessionID configured and this field would\r\n        be the differentiator\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"Identifier for the FIX sessionID.\"},{\"name\":\"msgSeqNum\",\"type\":\"int\",\"doc\":\"MsgSeqNum generated by the FIX engine for his session\"}],\"root\":\"true\"},\"null\"],\"doc\":\"* Id of raw message. It is used to make sure that raw message is not processed twice\",\"default\":null},{\"name\":\"rawType\",\"type\":[\"string\",\"null\"],\"doc\":\"* The type of the raw id (example RawFIXKeyType)\",\"default\":null},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null},{\"name\":\"symbol\",\"type\":\"string\",\"doc\":\"* The name of the currency pair where the first currency is the base currency. The two elements (base and terms) must be three-character ISO codes for a currency.\r\n*  For example, GBP/USD\"},{\"name\":\"account\",\"type\":\"string\",\"doc\":\"* The value received from the source system to identify the Firm's trading account identifier which can be linked to PM, firm accounting structure and etc.\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Strategy\",\"default\":null},{\"name\":\"fillStatus\",\"type\":\"string\",\"doc\":\"* Status of transaction NEW, AMEND, CANCEL\"},{\"name\":\"tradeDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Trade date of the transaction\",\"default\":null},{\"name\":\"custodian\",\"type\":[\"string\",\"null\"],\"doc\":\"* The value received from the source system to identify the Firms code for custodian account at PB to which fill was applied\r\n* {Optional}\",\"default\":null},{\"name\":\"broker\",\"type\":[\"string\",\"null\"],\"doc\":\"* The value received from the source system to identify the Firms code for execution broker id\",\"default\":null},{\"name\":\"line\",\"type\":[\"string\",\"null\"],\"doc\":\"* Execution line\",\"default\":null},{\"name\":\"settlementDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Settlement date if provided by the broker\",\"default\":null},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Fixing date\",\"default\":null},{\"name\":\"executionTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* Execution time set by market place\"},{\"name\":\"fillSide\",\"type\":\"string\",\"doc\":\"* Side of transaction BUY, SELL\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* Quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* Price\"},{\"name\":\"spotRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* Spot rate\",\"default\":null},{\"name\":\"forwardPoints\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* Forward Rate\",\"default\":null},{\"name\":\"senderCompId\",\"type\":\"string\",\"doc\":\"* Sender company id\"},{\"name\":\"targetCompId\",\"type\":\"string\",\"doc\":\"* Target company id\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* User id\",\"default\":null},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"* Deal currency\",\"default\":null},{\"name\":\"fillId\",\"type\":\"string\",\"doc\":\"* ExecID or ExecRefId based on whether the fill is new or cancel/correct\"},{\"name\":\"sequenceIdGeneratorType\",\"type\":[\"string\",\"null\"],\"doc\":\"* Type of sequence generator (STANDARD, SERVICE_BUREAU)\",\"default\":\"STANDARD\"},{\"name\":\"senderSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX SenderSubID\",\"default\":null},{\"name\":\"targetSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX TargetSubID\",\"default\":null},{\"name\":\"onBehalfOfCompId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX OnBehalfOfCompID\",\"default\":null},{\"name\":\"onBehalfOfSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX OnBehalfOfSubID\",\"default\":null},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"System time\",\"default\":null},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"populated from raw knowledge time\",\"default\":null},{\"name\":\"fillRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"Fill Reference Id(execRefId or tradeReportRefID)\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276586071,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "NormalizedEquity",
				"description": "*\"Schema for a FX Spot, Forward and NDF message received from FIX, file, manual entry, etc.\"",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 39,
			"timestamp": 1529421179903,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 39,
						"name": "MASTER",
						"schemaMetadataName": "NormalizedEquity",
						"description": "'MASTER' branch for schema metadata 'NormalizedEquity'",
						"timestamp": 1529421179904
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 432,
							"schemaMetadataId": 39,
							"name": "NormalizedEquity",
							"description": "*\"Schema for a FX Spot, Forward and NDF message received from FIX, file, manual entry, etc.\"",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"NormalizedEquity\",\"namespace\":\"firm.transaction.normalized.equity\",\"doc\":\"*\\\"Schema for a FX Spot, Forward and NDF message received from FIX, file, manual entry, etc.\\\"\",\"fields\":[{\"name\":\"rawId\",\"type\":[{\"type\":\"record\",\"name\":\"RawFIXKey\",\"namespace\":\"firm.transaction.raw.fix\",\"doc\":\"This key makes sure that all the FIX messages from a particular FIX session are always available on the same partition\",\"fields\":[{\"name\":\"sendingDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"The date when the messages was sent to us by the broker's fix engine\"},{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw FIX message originated\r\n        There is a possibility that two FIX engines can have the same SessionID configured and this field would\r\n        be the differentiator\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"Identifier for the FIX sessionID.\"},{\"name\":\"msgSeqNum\",\"type\":\"int\",\"doc\":\"MsgSeqNum generated by the FIX engine for his session\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"RawNeovestKey\",\"namespace\":\"firm.transaction.raw.neovest\",\"doc\":\"This key makes sure that all the Neovest messages from a particular FIX session are always available on the same partition\",\"fields\":[{\"name\":\"sendingDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"The dateTime when the messages was sent to us by the broker's fix engine, this is not the time when Neovest is sending us\"},{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw message originated\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"sessionId for messages from Neovest will be in the format SenderCompID++TargetCompID. This is because, a single instance of Neovest can receive messages from session with same sessionId, but different FIX engines. The combination has proved to be unique across FIX engines.\"},{\"name\":\"neoSysSeqNum\",\"type\":\"int\",\"doc\":\"neoSysSeqNum, Neovest generates a sysSeqNum which is sequential for all the messages that it publishes to allobridge user, it doesnot use the FIX MsgSeqNum\"}],\"root\":\"true\"}],\"doc\":\"* Id of raw message. It is used to make sure that raw message is not processed twice\",\"default\":null},{\"name\":\"rawType\",\"type\":[\"string\",\"null\"],\"doc\":\"* The type of the raw id (example RawFIXKeyType)\",\"default\":null},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null},{\"name\":\"symbol\",\"type\":\"string\",\"doc\":\"* The name of the currency pair where the first currency is the base currency. The two elements (base and terms) must be three-character ISO codes for a currency.\r\n*  For example, GBP/USD\"},{\"name\":\"account\",\"type\":\"string\",\"doc\":\"* The value received from the source system to identify the Firm's trading account identifier which can be linked to PM, firm accounting structure and etc.\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Strategy\",\"default\":null},{\"name\":\"fillStatus\",\"type\":\"string\",\"doc\":\"* Status of transaction LIVE, CANCELED\"},{\"name\":\"tradeDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Trade date of the transaction\",\"default\":null},{\"name\":\"custodian\",\"type\":[\"string\",\"null\"],\"doc\":\"* The value received from the source system to identify the Firms code for custodian account at PB to which fill was applied\r\n* {Optional}\",\"default\":null},{\"name\":\"broker\",\"type\":[\"string\",\"null\"],\"doc\":\"* The value received from the source system to identify the Firms code for execution broker id\",\"default\":null},{\"name\":\"line\",\"type\":[\"string\",\"null\"],\"doc\":\"* Execution line\",\"default\":null},{\"name\":\"settlementDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Settlement date if provided by the broker\",\"default\":null},{\"name\":\"executionTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* Execution time set by market place\"},{\"name\":\"fillSide\",\"type\":\"string\",\"doc\":\"* Side of transaction BUY, SELL\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* Quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* Price\"},{\"name\":\"senderCompId\",\"type\":\"string\",\"doc\":\"* Sender company id\"},{\"name\":\"targetCompId\",\"type\":\"string\",\"doc\":\"* Target company id\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* User id\",\"default\":null},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"* Deal currency\",\"default\":null},{\"name\":\"fillId\",\"type\":\"string\",\"doc\":\"* ExecID or ExecRefId based on whether the fill is new or cancel/correct\"},{\"name\":\"sequenceIdGeneratorType\",\"type\":[\"string\",\"null\"],\"doc\":\"* Type of sequence generator (STANDARD, SERVICE_BUREAU)\",\"default\":null},{\"name\":\"senderSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX SenderSubID\",\"default\":null},{\"name\":\"targetSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX TargetSubID\",\"default\":null},{\"name\":\"onBehalfOfCompId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX OnBehalfOfCompID\",\"default\":null},{\"name\":\"onBehalfOfSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX OnBehalfOfSubID\",\"default\":null},{\"name\":\"swapIdentifier\",\"type\":[\"string\",\"null\"],\"doc\":\"* Field to identify if the current transaction is for a swap execution and if so a straight swap or a dollarized swap. \r\n* A value SWP indicates a straight swap, USW will indicate dolarized and CFD indicate contract for difference. If the value is null, it indicates cash.\",\"default\":null},{\"name\":\"fillRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"Fill Reference Id(execRefId or tradeReportRefID)\",\"default\":null},{\"name\":\"idSource\",\"type\":\"string\",\"doc\":\"*IDSource to identify the Symbol type (RIC, BBG, Exchange etc.,) for enhancer to be able to *lookup the appropriate Security Lookup Caches.\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"System time\",\"default\":null},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"populated from raw knowledge time\",\"default\":null},{\"name\":\"settlCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"Settlement Currency for dollarized swaps\"},{\"name\":\"settlCurrFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"Settlement Currency FxRateCalc for dollarized swaps\"},{\"name\":\"settlCurrFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Settlement Currency FxRate for dollarized swaps\"}],\"root\":\"true\"}",
							"timestamp": 1530276584835,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "Lookup",
				"description": "Lookup schema for Lookup Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 38,
			"timestamp": 1529421179740,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 38,
						"name": "MASTER",
						"schemaMetadataName": "Lookup",
						"description": "'MASTER' branch for schema metadata 'Lookup'",
						"timestamp": 1529421179741
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 430,
							"schemaMetadataId": 38,
							"name": "Lookup",
							"description": "Lookup schema for Lookup Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"Lookup\",\"namespace\":\"firm.lookup\",\"doc\":\"Lookup schema for Lookup Stream\",\"fields\":[{\"name\":\"id\",\"type\":[\"string\",\"null\"],\"doc\":\"id\"},{\"name\":\"code\",\"type\":[\"string\",\"null\"],\"doc\":\"code\"},{\"name\":\"name\",\"type\":[\"string\",\"null\"],\"doc\":\"name\"}],\"root\":\"true\"}",
							"timestamp": 1530276583636,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "LastPrice",
				"description": "Security last tick price",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 37,
			"timestamp": 1529421179579,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 37,
						"name": "MASTER",
						"schemaMetadataName": "LastPrice",
						"description": "'MASTER' branch for schema metadata 'LastPrice'",
						"timestamp": 1529421179580
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 472,
							"schemaMetadataId": 37,
							"name": "LastPrice",
							"description": "Security last tick price",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"LastPrice\",\"namespace\":\"firm.journal\",\"doc\":\"Security last tick price\",\"fields\":[{\"name\":\"lastPrice\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* security last price\"},{\"name\":\"timeCreatedPrice\",\"type\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"},\"doc\":\"time when the price was created to be used to determine latency in the system.\"}],\"root\":\"true\"}",
							"timestamp": 1530554025029,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "KnowledgeEvent",
				"description": "Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 36,
			"timestamp": 1529421178970,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 36,
						"name": "MASTER",
						"schemaMetadataName": "KnowledgeEvent",
						"description": "'MASTER' branch for schema metadata 'KnowledgeEvent'",
						"timestamp": 1529421178971
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 470,
							"schemaMetadataId": 36,
							"name": "KnowledgeEvent",
							"description": "Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash",
							"version": 7,
							"schemaText": "{\"type\":\"record\",\"name\":\"KnowledgeEvent\",\"namespace\":\"firm.journal\",\"doc\":\"Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash\",\"fields\":[{\"name\":\"eventType\",\"type\":{\"type\":\"enum\",\"name\":\"EventType\",\"doc\":\"* Represents the transaction type\",\"symbols\":[\"TRANSACTION\",\"FXRATE\",\"PRICE\",\"MATURITY\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: TRANSACTION, FX, PRICE..\"},{\"name\":\"event\",\"type\":[{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"custodianAccountId\",\"type\":[\"null\",\"string\"],\"doc\":\"CustodianAccountId. Input from Event data\",\"default\":null},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Local Price. For Dollarized Swaps, VWAP calculated based on the Input from Event data (or) Mark-Price\",\"default\":null},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Settlement FX Rate. For Dollarized Swaps\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODFXRate\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"underlyerRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerRate - for dollarizedSwap, this rate would be the underlyers fx rate\",\"default\":null},{\"name\":\"forwardRates\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"EODFXForwardRate\",\"doc\":\"EOD FX Forward Rate\",\"fields\":[{\"name\":\"forwardCurrency\",\"type\":\"string\",\"doc\":\"Forward Currency\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. Business date. Input from Event data\"},{\"name\":\"forwardDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"ForwardDate. Input from Event data\"},{\"name\":\"forwardRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Forward. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}},\"null\"],\"doc\":\"ForwardRates - One or Two forward rates for the FX forward\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODPrice\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"underlyerPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerPrice - Price of the underlyer. For DollarizedSwap, this would be tbe price of the underlyer\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"MaturityEvent\",\"doc\":\"Maturity Event Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID.\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"ID. Generated by maturity event system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"null\",\"string\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"eventState\",\"type\":{\"type\":\"enum\",\"name\":\"EventState\",\"doc\":\"Event State.\",\"symbols\":[\"NEW\",\"CANCEL\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, CANCEL\"}],\"root\":\"true\"}],\"doc\":\"Event data.. It can be one of AggregatedTransaction, FX or Price.\"},{\"name\":\"investmentTypes\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Investment type. Ex: SECURITY, CASH ..\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"timeCreated\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"created time.\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530540068300,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 428,
							"schemaMetadataId": 36,
							"name": "KnowledgeEvent",
							"description": "Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash",
							"version": 6,
							"schemaText": "{\"type\":\"record\",\"name\":\"KnowledgeEvent\",\"namespace\":\"firm.journal\",\"doc\":\"Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash\",\"fields\":[{\"name\":\"eventType\",\"type\":{\"type\":\"enum\",\"name\":\"EventType\",\"doc\":\"* Represents the transaction type\",\"symbols\":[\"TRANSACTION\",\"FXRATE\",\"PRICE\",\"MATURITY\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: TRANSACTION, FX, PRICE..\"},{\"name\":\"event\",\"type\":[{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Local Price. For Dollarized Swaps, VWAP calculated based on the Input from Event data (or) Mark-Price\",\"default\":null},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Settlement FX Rate. For Dollarized Swaps\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODFXRate\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"underlyerRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerRate - for dollarizedSwap, this rate would be the underlyers fx rate\",\"default\":null},{\"name\":\"forwardRates\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"EODFXForwardRate\",\"doc\":\"EOD FX Forward Rate\",\"fields\":[{\"name\":\"forwardCurrency\",\"type\":\"string\",\"doc\":\"Forward Currency\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. Business date. Input from Event data\"},{\"name\":\"forwardDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"ForwardDate. Input from Event data\"},{\"name\":\"forwardRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Forward. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}},\"null\"],\"doc\":\"ForwardRates - One or Two forward rates for the FX forward\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODPrice\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"underlyerPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerPrice - Price of the underlyer. For DollarizedSwap, this would be tbe price of the underlyer\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"MaturityEvent\",\"doc\":\"Maturity Event Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID.\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"ID. Generated by maturity event system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"null\",\"string\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"eventState\",\"type\":{\"type\":\"enum\",\"name\":\"EventState\",\"doc\":\"Event State.\",\"symbols\":[\"NEW\",\"CANCEL\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, CANCEL\"}],\"root\":\"true\"}],\"doc\":\"Event data.. It can be one of AggregatedTransaction, FX or Price.\"},{\"name\":\"investmentTypes\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Investment type. Ex: SECURITY, CASH ..\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"timeCreated\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"created time.\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276580930,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 427,
							"schemaMetadataId": 36,
							"name": "KnowledgeEvent",
							"description": "Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash",
							"version": 5,
							"schemaText": "{\"type\":\"record\",\"name\":\"KnowledgeEvent\",\"namespace\":\"firm.journal\",\"doc\":\"Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash\",\"fields\":[{\"name\":\"eventType\",\"type\":{\"type\":\"enum\",\"name\":\"EventType\",\"doc\":\"* Represents the transaction type\",\"symbols\":[\"TRANSACTION\",\"FXRATE\",\"PRICE\",\"MATURITY\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: TRANSACTION, FX, PRICE..\"},{\"name\":\"event\",\"type\":[{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Local Price. For Dollarized Swaps, VWAP calculated based on the Input from Event data (or) Mark-Price\",\"default\":null},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Settlement FX Rate. For Dollarized Swaps\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODFXRate\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"underlyerRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerRate - for dollarizedSwap, this rate would be the underlyers fx rate\",\"default\":null},{\"name\":\"forwardRates\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"EODFXForwardRate\",\"doc\":\"EOD FX Forward Rate\",\"fields\":[{\"name\":\"forwardCurrency\",\"type\":\"string\",\"doc\":\"Forward Currency\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. Business date. Input from Event data\"},{\"name\":\"forwardDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"ForwardDate. Input from Event data\"},{\"name\":\"forwardRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Forward. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}},\"null\"],\"doc\":\"ForwardRates - One or Two forward rates for the FX forward\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODPrice\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"underlyerPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerPrice - Price of the underlyer. For DollarizedSwap, this would be tbe price of the underlyer\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}],\"doc\":\"Event data.. It can be one of AggregatedTransaction, FX or Price.\"},{\"name\":\"investmentTypes\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Investment type. Ex: SECURITY, CASH ..\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"timeCreated\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"created time.\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276580348,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 426,
							"schemaMetadataId": 36,
							"name": "KnowledgeEvent",
							"description": "Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash",
							"version": 4,
							"schemaText": "{\"type\":\"record\",\"name\":\"KnowledgeEvent\",\"namespace\":\"firm.journal\",\"doc\":\"Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash\",\"fields\":[{\"name\":\"eventType\",\"type\":{\"type\":\"enum\",\"name\":\"EventType\",\"doc\":\"* Represents the transaction type\",\"symbols\":[\"TRANSACTION\",\"FXRATE\",\"PRICE\",\"MATURITY\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: TRANSACTION, FX, PRICE..\"},{\"name\":\"event\",\"type\":[{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Local Price. For Dollarized Swaps, VWAP calculated based on the Input from Event data (or) Mark-Price\",\"default\":null},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Settlement FX Rate. For Dollarized Swaps\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODFXRate\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"underlyerRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerRate - for dollarizedSwap, this rate would be the underlyers fx rate\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODPrice\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"underlyerPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerPrice - Price of the underlyer. For DollarizedSwap, this would be tbe price of the underlyer\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}],\"doc\":\"Event data.. It can be one of AggregatedTransaction, FX or Price.\"},{\"name\":\"investmentTypes\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Investment type. Ex: SECURITY, CASH ..\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"timeCreated\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"created time.\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276580037,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 425,
							"schemaMetadataId": 36,
							"name": "KnowledgeEvent",
							"description": "Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash",
							"version": 3,
							"schemaText": "{\"type\":\"record\",\"name\":\"KnowledgeEvent\",\"namespace\":\"firm.journal\",\"doc\":\"Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash\",\"fields\":[{\"name\":\"eventType\",\"type\":{\"type\":\"enum\",\"name\":\"EventType\",\"doc\":\"* Represents the transaction type\",\"symbols\":[\"TRANSACTION\",\"FXRATE\",\"PRICE\",\"MATURITY\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: TRANSACTION, FX, PRICE..\"},{\"name\":\"event\",\"type\":[{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"pricingFactor\",\"type\":[\"null\",\"firm.type.BigDecimal\"],\"doc\":\"Pricing Factor. Input from Security Master. TODO: how to handle the changes to the value? *\"},{\"name\":\"scalingFactor\",\"type\":[\"null\",\"firm.type.BigDecimal\"],\"doc\":\"Scaling Factor. Input from Security master. TODO: how to handle the changes to the value? *\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODFXRate\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODPrice\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}],\"doc\":\"Event data.. It can be one of AggregatedTransaction, FX or Price.\"},{\"name\":\"investmentTypes\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Investment type. Ex: SECURITY, CASH ..\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276579859,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 424,
							"schemaMetadataId": 36,
							"name": "KnowledgeEvent",
							"description": "Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"KnowledgeEvent\",\"namespace\":\"firm.journal\",\"doc\":\"Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash\",\"fields\":[{\"name\":\"eventType\",\"type\":{\"type\":\"enum\",\"name\":\"EventType\",\"doc\":\"* Represents the transaction type\",\"symbols\":[\"TRANSACTION\",\"FXRATE\",\"PRICE\",\"MATURITY\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: TRANSACTION, FX, PRICE..\"},{\"name\":\"event\",\"type\":[{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"pricingFactor\",\"type\":[\"null\",\"firm.type.BigDecimal\"],\"doc\":\"Pricing Factor. Input from Security Master. TODO: how to handle the changes to the value? *\"},{\"name\":\"scalingFactor\",\"type\":[\"null\",\"firm.type.BigDecimal\"],\"doc\":\"Scaling Factor. Input from Security master. TODO: how to handle the changes to the value? *\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODFXRate\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODPrice\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}],\"doc\":\"Event data.. It can be one of AggregatedTransaction, FX or Price.\"},{\"name\":\"investmentTypes\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Investment type. Ex: SECURITY, CASH ..\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276579155,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 423,
							"schemaMetadataId": 36,
							"name": "KnowledgeEvent",
							"description": "Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"KnowledgeEvent\",\"namespace\":\"firm.journal\",\"doc\":\"Knowledge event schema. This schema wraps the actual event and adds meta data (investmenttype) so that journaler system knows whether its a security or cash\",\"fields\":[{\"name\":\"eventType\",\"type\":{\"type\":\"enum\",\"name\":\"EventType\",\"doc\":\"* Represents the transaction type\",\"symbols\":[\"TRANSACTION\",\"FXRATE\",\"PRICE\",\"MATURITY\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: TRANSACTION, FX, PRICE..\"},{\"name\":\"event\",\"type\":[{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"pricingFactor\",\"type\":[\"null\",\"firm.type.BigDecimal\"],\"doc\":\"Pricing Factor. Input from Security Master. TODO: how to handle the changes to the value? *\"},{\"name\":\"scalingFactor\",\"type\":[\"null\",\"firm.type.BigDecimal\"],\"doc\":\"Scaling Factor. Input from Security master. TODO: how to handle the changes to the value? *\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODFXRate\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"EODPrice\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}],\"doc\":\"Event data.. It can be one of AggregatedTransaction, FX or Price.\"},{\"name\":\"investmentTypes\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Investment type. Ex: SECURITY, CASH ..\"}],\"root\":\"true\"}",
							"timestamp": 1530276578599,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "JournalKey",
				"description": "Journal Entry Key Schema.",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 35,
			"timestamp": 1529421178815,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 35,
						"name": "MASTER",
						"schemaMetadataName": "JournalKey",
						"description": "'MASTER' branch for schema metadata 'JournalKey'",
						"timestamp": 1529421178816
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 422,
							"schemaMetadataId": 35,
							"name": "JournalKey",
							"description": "Journal Entry Key Schema.",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"JournalKey\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Key Schema.\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"TradingArea\"}],\"root\":\"true\"}",
							"timestamp": 1530276577702,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "Journal",
				"description": "Journal Entry Schema.",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 34,
			"timestamp": 1529421178237,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 34,
						"name": "MASTER",
						"schemaMetadataName": "Journal",
						"description": "'MASTER' branch for schema metadata 'Journal'",
						"timestamp": 1529421178237
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 469,
							"schemaMetadataId": 34,
							"name": "Journal",
							"description": "Journal Entry Schema.",
							"version": 7,
							"schemaText": "{\"type\":\"record\",\"name\":\"Journal\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"entries\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"JournalEntry\",\"fields\":[{\"name\":\"journalState\",\"type\":{\"type\":\"enum\",\"name\":\"JournalState\",\"doc\":\"Journal Entry Action type.\",\"symbols\":[\"NEW\",\"BACKOUT\",\"REBOOK\",\"MARKPRICE\",\"MARKPRICEBACKOUT\",\"MARKPRICEREBOOK\",\"MARKFX\",\"MARKFXBACKOUT\",\"MARKFXREBOOK\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, BACKOUT ..\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"lotId\",\"type\":\"string\",\"doc\":\"LotNumber.\"},{\"name\":\"lotOrder\",\"type\":\"long\",\"doc\":\"LotOrder. this is used to effectively handle ordering logic\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"custodianAccountId\",\"type\":[\"null\",\"string\"],\"doc\":\"CustodianAccountId. Input from Event data\",\"default\":null},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"childInvestmentId\",\"type\":[\"string\",\"null\"],\"doc\":\"Investment. Input from Event data\",\"default\":\"\"},{\"name\":\"financialAccount\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccount\",\"doc\":\"Financial Account type.\",\"symbols\":[\"COST\",\"BackoutUnrealizedCrossNAV\",\"BackoutUnrealizedCrossNAVNotional\",\"BackoutUnrealizedCrossPnL\",\"BackoutUnrealizedCrossPnLNotional\",\"BackoutUnrealizedFxNAV\",\"BackoutUnrealizedFxNAVNotional\",\"BackoutUnrealizedFxPnL\",\"BackoutUnrealizedFxPnLNotional\",\"BackoutUnrealizedPxNAV\",\"BackoutUnrealizedPxNAVNotional\",\"BackoutUnrealizedPxPnL\",\"BackoutUnrealizedPxPnLNotional\",\"CostNotional\",\"RealizedCrossPnL\",\"RealizedCrossPnLNotional\",\"RealizedFxPnL\",\"RealizedFxPnLNotional\",\"RealizedPxPnL\",\"RealizedPxPnLNotional\",\"UnrealizedCrossNAV\",\"UnrealizedCrossNAVNotional\",\"UnrealizedCrossPnL\",\"UnrealizedCrossPnLNotional\",\"UnrealizedFxNAV\",\"UnrealizedFxNAVNotional\",\"UnrealizedFxPnL\",\"UnrealizedFXPnLNotional\",\"UnrealizedPxNAV\",\"UnrealizedPxNAVNotional\",\"UnrealizedPxPnL\",\"UnrealizedPxPnLNotional\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccount. Different types of Journal entry types.. ex: Realized PnL, Un-realized PnL\"},{\"name\":\"financialAccountCategory\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccountCategory\",\"doc\":\"Fin Account type.\",\"symbols\":[\"NAV\",\"PNL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccountValueType. Ex: NAV, PnL\"},{\"name\":\"journalAttribute\",\"type\":{\"type\":\"enum\",\"name\":\"JournalAttribute\",\"doc\":\"* Represents the category of journal entry\",\"symbols\":[\"QUANTITY\",\"LOCAL\",\"BOOK\"],\"type-only\":\"true\"},\"doc\":\"Category. Ex: Local, Book, Quantity..\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"amount\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"Amount.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"type-only\":\"true\"}},\"doc\":\"List of journals\"},{\"name\":\"timeCreated\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"created time.\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"maxTopicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":\"firm.type.TopicPartitionOffset\"},\"doc\":\"Map of Max TopicPartitionOffset for all topics\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530540068067,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 468,
							"schemaMetadataId": 34,
							"name": "Journal",
							"description": "Journal Entry Schema.",
							"version": 6,
							"schemaText": "{\"type\":\"record\",\"name\":\"Journal\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"entries\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"JournalEntry\",\"fields\":[{\"name\":\"journalState\",\"type\":{\"type\":\"enum\",\"name\":\"JournalState\",\"doc\":\"Journal Entry Action type.\",\"symbols\":[\"NEW\",\"BACKOUT\",\"REBOOK\",\"MARKPRICE\",\"MARKPRICEBACKOUT\",\"MARKPRICEREBOOK\",\"MARKFX\",\"MARKFXBACKOUT\",\"MARKFXREBOOK\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, BACKOUT ..\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"lotId\",\"type\":\"string\",\"doc\":\"LotNumber.\"},{\"name\":\"lotOrder\",\"type\":\"long\",\"doc\":\"LotOrder. this is used to effectively handle ordering logic\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"childInvestmentId\",\"type\":[\"string\",\"null\"],\"doc\":\"Investment. Input from Event data\",\"default\":\"\"},{\"name\":\"financialAccount\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccount\",\"doc\":\"Financial Account type.\",\"symbols\":[\"COST\",\"BackoutUnrealizedCrossNAV\",\"BackoutUnrealizedCrossNAVNotional\",\"BackoutUnrealizedCrossPnL\",\"BackoutUnrealizedCrossPnLNotional\",\"BackoutUnrealizedFxNAV\",\"BackoutUnrealizedFxNAVNotional\",\"BackoutUnrealizedFxPnL\",\"BackoutUnrealizedFxPnLNotional\",\"BackoutUnrealizedPxNAV\",\"BackoutUnrealizedPxNAVNotional\",\"BackoutUnrealizedPxPnL\",\"BackoutUnrealizedPxPnLNotional\",\"CostNotional\",\"RealizedCrossPnL\",\"RealizedCrossPnLNotional\",\"RealizedFxPnL\",\"RealizedFxPnLNotional\",\"RealizedPxPnL\",\"RealizedPxPnLNotional\",\"UnrealizedCrossNAV\",\"UnrealizedCrossNAVNotional\",\"UnrealizedCrossPnL\",\"UnrealizedCrossPnLNotional\",\"UnrealizedFxNAV\",\"UnrealizedFxNAVNotional\",\"UnrealizedFxPnL\",\"UnrealizedFXPnLNotional\",\"UnrealizedPxNAV\",\"UnrealizedPxNAVNotional\",\"UnrealizedPxPnL\",\"UnrealizedPxPnLNotional\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccount. Different types of Journal entry types.. ex: Realized PnL, Un-realized PnL\"},{\"name\":\"financialAccountCategory\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccountCategory\",\"doc\":\"Fin Account type.\",\"symbols\":[\"NAV\",\"PNL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccountValueType. Ex: NAV, PnL\"},{\"name\":\"journalAttribute\",\"type\":{\"type\":\"enum\",\"name\":\"JournalAttribute\",\"doc\":\"* Represents the category of journal entry\",\"symbols\":[\"QUANTITY\",\"LOCAL\",\"BOOK\"],\"type-only\":\"true\"},\"doc\":\"Category. Ex: Local, Book, Quantity..\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"amount\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"Amount.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"type-only\":\"true\"}},\"doc\":\"List of journals\"},{\"name\":\"timeCreated\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"created time.\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"maxTopicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":\"firm.type.TopicPartitionOffset\"},\"doc\":\"Map of Max TopicPartitionOffset for all topics\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530540067946,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 421,
							"schemaMetadataId": 34,
							"name": "Journal",
							"description": "Journal Entry Schema.",
							"version": 5,
							"schemaText": "{\"type\":\"record\",\"name\":\"Journal\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"entries\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"JournalEntry\",\"fields\":[{\"name\":\"journalState\",\"type\":{\"type\":\"enum\",\"name\":\"JournalState\",\"doc\":\"Journal Entry Action type.\",\"symbols\":[\"NEW\",\"BACKOUT\",\"REBOOK\",\"MARKPRICE\",\"MARKPRICEBACKOUT\",\"MARKPRICEREBOOK\",\"MARKFX\",\"MARKFXBACKOUT\",\"MARKFXREBOOK\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, BACKOUT ..\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"lotId\",\"type\":\"string\",\"doc\":\"LotNumber.\"},{\"name\":\"lotOrder\",\"type\":\"long\",\"doc\":\"LotOrder. this is used to effectively handle ordering logic\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"childInvestmentId\",\"type\":[\"string\",\"null\"],\"doc\":\"Investment. Input from Event data\",\"default\":\"\"},{\"name\":\"financialAccount\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccount\",\"doc\":\"Financial Account type.\",\"symbols\":[\"COST\",\"UnrealizedPxNAV\",\"UnrealizedPxPnL\",\"UnrealizedFxNAV\",\"UnrealizedFxPnL\",\"UnrealizedCrossNAV\",\"UnrealizedCrossPnL\",\"RealizedPxPnL\",\"RealizedFxPnL\",\"RealizedCrossPnL\",\"BackoutUnrealizedPxNAV\",\"BackoutUnrealizedPxPnL\",\"BackoutUnrealizedFxNAV\",\"BackoutUnrealizedFxPnL\",\"BackoutUnrealizedCrossNAV\",\"BackoutUnrealizedCrossPnL\",\"CostNotional\",\"UnrealizedPxNAVNotional\",\"UnrealizedPxPnLNotional\",\"UnrealizedFxNAVNotional\",\"UnrealizedFXPnLNotional\",\"UnrealizedCrossNAVNotional\",\"UnrealizedCrossPnLNotional\",\"BackoutUnrealizedPxNAVNotional\",\"BackoutUnrealizedPxPnLNotional\",\"BackoutUnrealizedFxNAVNotional\",\"BackoutUnrealizedFxPnLNotional\",\"BackoutUnrealizedCrossNAVNotional\",\"BackoutUnrealizedCrossPnLNotional\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccount. Different types of Journal entry types.. ex: Realized PnL, Un-realized PnL\"},{\"name\":\"financialAccountCategory\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccountCategory\",\"doc\":\"Fin Account type.\",\"symbols\":[\"NAV\",\"PNL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccountValueType. Ex: NAV, PnL\"},{\"name\":\"journalAttribute\",\"type\":{\"type\":\"enum\",\"name\":\"JournalAttribute\",\"doc\":\"* Represents the category of journal entry\",\"symbols\":[\"QUANTITY\",\"LOCAL\",\"BOOK\"],\"type-only\":\"true\"},\"doc\":\"Category. Ex: Local, Book, Quantity..\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"amount\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"Amount.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"type-only\":\"true\"}},\"doc\":\"List of journals\"},{\"name\":\"timeCreated\",\"type\":[\"firm.type.LocalDateTime\",\"null\"],\"doc\":\"created time.\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"maxTopicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":\"firm.type.TopicPartitionOffset\"},\"doc\":\"Map of Max TopicPartitionOffset for all topics\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276576467,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 420,
							"schemaMetadataId": 34,
							"name": "Journal",
							"description": "Journal Entry Schema.",
							"version": 4,
							"schemaText": "{\"type\":\"record\",\"name\":\"Journal\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"entries\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"JournalEntry\",\"fields\":[{\"name\":\"journalState\",\"type\":{\"type\":\"enum\",\"name\":\"JournalState\",\"doc\":\"Journal Entry Action type.\",\"symbols\":[\"NEW\",\"BACKOUT\",\"REBOOK\",\"MARKPRICE\",\"MARKPRICEBACKOUT\",\"MARKPRICEREBOOK\",\"MARKFX\",\"MARKFXBACKOUT\",\"MARKFXREBOOK\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, BACKOUT ..\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"lotId\",\"type\":\"string\",\"doc\":\"LotNumber.\"},{\"name\":\"lotOrder\",\"type\":\"long\",\"doc\":\"LotOrder. this is used to effectively handle ordering logic\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"childInvestmentId\",\"type\":[\"string\",\"null\"],\"doc\":\"Investment. Input from Event data\",\"default\":\"\"},{\"name\":\"financialAccount\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccount\",\"doc\":\"Financial Account type.\",\"symbols\":[\"COST\",\"UnrealizedPxNAV\",\"UnrealizedPxPnL\",\"UnrealizedFxNAV\",\"UnrealizedFxPnL\",\"UnrealizedCrossNAV\",\"UnrealizedCrossPnL\",\"RealizedPxPnL\",\"RealizedFxPnL\",\"RealizedCrossPnL\",\"BackoutUnrealizedPxNAV\",\"BackoutUnrealizedPxPnL\",\"BackoutUnrealizedFxNAV\",\"BackoutUnrealizedFxPnL\",\"BackoutUnrealizedCrossNAV\",\"BackoutUnrealizedCrossPnL\",\"CostNotional\",\"UnrealizedPxNAVNotional\",\"UnrealizedPxPnLNotional\",\"UnrealizedFxNAVNotional\",\"UnrealizedFXPnLNotional\",\"UnrealizedCrossNAVNotional\",\"UnrealizedCrossPnLNotional\",\"BackoutUnrealizedPxNAVNotional\",\"BackoutUnrealizedPxPnLNotional\",\"BackoutUnrealizedFxNAVNotional\",\"BackoutUnrealizedFxPnLNotional\",\"BackoutUnrealizedCrossNAVNotional\",\"BackoutUnrealizedCrossPnLNotional\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccount. Different types of Journal entry types.. ex: Realized PnL, Un-realized PnL\"},{\"name\":\"financialAccountCategory\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccountCategory\",\"doc\":\"Fin Account type.\",\"symbols\":[\"NAV\",\"PNL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccountValueType. Ex: NAV, PnL\"},{\"name\":\"journalAttribute\",\"type\":{\"type\":\"enum\",\"name\":\"JournalAttribute\",\"doc\":\"* Represents the category of journal entry\",\"symbols\":[\"QUANTITY\",\"LOCAL\",\"BOOK\"],\"type-only\":\"true\"},\"doc\":\"Category. Ex: Local, Book, Quantity..\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"amount\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"Amount.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"type-only\":\"true\"}},\"doc\":\"List of journals\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"maxTopicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":\"firm.type.TopicPartitionOffset\"},\"doc\":\"Map of Max TopicPartitionOffset for all topics\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276576331,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 419,
							"schemaMetadataId": 34,
							"name": "Journal",
							"description": "Journal Entry Schema.",
							"version": 3,
							"schemaText": "{\"type\":\"record\",\"name\":\"Journal\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"entries\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"JournalEntry\",\"fields\":[{\"name\":\"journalState\",\"type\":{\"type\":\"enum\",\"name\":\"JournalState\",\"doc\":\"Journal Entry Action type.\",\"symbols\":[\"NEW\",\"BACKOUT\",\"REBOOK\",\"MARKPRICE\",\"MARKPRICEBACKOUT\",\"MARKPRICEREBOOK\",\"MARKFX\",\"MARKFXBACKOUT\",\"MARKFXREBOOK\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, BACKOUT ..\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"lotId\",\"type\":\"string\",\"doc\":\"LotNumber.\"},{\"name\":\"lotOrder\",\"type\":\"long\",\"doc\":\"LotOrder. this is used to effectively handle ordering logic\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"financialAccount\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccount\",\"doc\":\"Financial Account type.\",\"symbols\":[\"COST\",\"UnrealizedPxNAV\",\"UnrealizedPxPnL\",\"UnrealizedFxNAV\",\"UnrealizedFxPnL\",\"UnrealizedCrossNAV\",\"UnrealizedCrossPnL\",\"RealizedPxPnL\",\"RealizedFxPnL\",\"RealizedCrossPnL\",\"BackoutUnrealizedPxNAV\",\"BackoutUnrealizedPxPnL\",\"BackoutUnrealizedFxNAV\",\"BackoutUnrealizedFxPnL\",\"BackoutUnrealizedCrossNAV\",\"BackoutUnrealizedCrossPnL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccount. Different types of Journal entry types.. ex: Realized PnL, Un-realized PnL\"},{\"name\":\"financialAccountCategory\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccountCategory\",\"doc\":\"Fin Account type.\",\"symbols\":[\"NAV\",\"PNL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccountValueType. Ex: NAV, PnL\"},{\"name\":\"journalAttribute\",\"type\":{\"type\":\"enum\",\"name\":\"JournalAttribute\",\"doc\":\"* Represents the category of journal entry\",\"symbols\":[\"QUANTITY\",\"LOCAL\",\"BOOK\"],\"type-only\":\"true\"},\"doc\":\"Category. Ex: Local, Book, Quantity..\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"amount\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"Amount.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"type-only\":\"true\"}},\"doc\":\"List of journals\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"maxTopicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":\"firm.type.TopicPartitionOffset\"},\"doc\":\"Map of Max TopicPartitionOffset for all topics\",\"default\":null},{\"name\":\"headers\",\"type\":[{\"type\":\"map\",\"values\":\"bytes\"},\"null\"],\"doc\":\"Map of metadata headers in lieu of Kafka headers in versions >= 0.11 *\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276576200,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 418,
							"schemaMetadataId": 34,
							"name": "Journal",
							"description": "Journal Entry Schema.",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"Journal\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"entries\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"JournalEntry\",\"fields\":[{\"name\":\"journalState\",\"type\":{\"type\":\"enum\",\"name\":\"JournalState\",\"doc\":\"Journal Entry Action type.\",\"symbols\":[\"NEW\",\"BACKOUT\",\"REBOOK\",\"MARKPRICE\",\"MARKPRICEBACKOUT\",\"MARKPRICEREBOOK\",\"MARKFX\",\"MARKFXBACKOUT\",\"MARKFXREBOOK\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, BACKOUT ..\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"lotId\",\"type\":\"string\",\"doc\":\"LotNumber.\"},{\"name\":\"lotOrder\",\"type\":\"long\",\"doc\":\"LotOrder. this is used to effectively handle ordering logic\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"financialAccount\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccount\",\"doc\":\"Financial Account type.\",\"symbols\":[\"COST\",\"UnrealizedPxNAV\",\"UnrealizedPxPnL\",\"UnrealizedFxNAV\",\"UnrealizedFxPnL\",\"UnrealizedCrossNAV\",\"UnrealizedCrossPnL\",\"RealizedPxPnL\",\"RealizedFxPnL\",\"RealizedCrossPnL\",\"BackoutUnrealizedPxNAV\",\"BackoutUnrealizedPxPnL\",\"BackoutUnrealizedFxNAV\",\"BackoutUnrealizedFxPnL\",\"BackoutUnrealizedCrossNAV\",\"BackoutUnrealizedCrossPnL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccount. Different types of Journal entry types.. ex: Realized PnL, Un-realized PnL\"},{\"name\":\"financialAccountCategory\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccountCategory\",\"doc\":\"Fin Account type.\",\"symbols\":[\"NAV\",\"PNL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccountValueType. Ex: NAV, PnL\"},{\"name\":\"journalAttribute\",\"type\":{\"type\":\"enum\",\"name\":\"JournalAttribute\",\"doc\":\"* Represents the category of journal entry\",\"symbols\":[\"QUANTITY\",\"LOCAL\",\"BOOK\"],\"type-only\":\"true\"},\"doc\":\"Category. Ex: Local, Book, Quantity..\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"amount\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"Amount.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"type-only\":\"true\"}},\"doc\":\"List of journals\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"},{\"name\":\"topicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"TopicPartitionOffset\",\"namespace\":\"firm.type\",\"doc\":\"Topic, Partition, offset\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"Topic Name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"Offset\"}],\"type-only\":\"true\",\"logicalType\":\"TopicPartitionOffset\"}},\"doc\":\"Map of TopicPartitionOffset\",\"default\":null},{\"name\":\"maxTopicPartitionMap\",\"type\":{\"type\":\"map\",\"values\":\"firm.type.TopicPartitionOffset\"},\"doc\":\"Map of Max TopicPartitionOffset for all topics\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276575672,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 417,
							"schemaMetadataId": 34,
							"name": "Journal",
							"description": "Journal Entry Schema.",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"Journal\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"entries\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"JournalEntry\",\"fields\":[{\"name\":\"journalState\",\"type\":{\"type\":\"enum\",\"name\":\"JournalState\",\"doc\":\"Journal Entry Action type.\",\"symbols\":[\"NEW\",\"BACKOUT\",\"REBOOK\",\"MARKPRICE\",\"MARKPRICEBACKOUT\",\"MARKPRICEREBOOK\",\"MARKFX\",\"MARKFXBACKOUT\",\"MARKFXREBOOK\"],\"type-only\":\"true\"},\"doc\":\"Event type. Ex: NEW, BACKOUT ..\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate.\r\n    it is the business date to which the activity is applied for the purposes of reporting.\r\n    It is overridable by business users.\r\n    Ex: Trade executed for 1/1/2000 can have a AppliedKnowledgeDate as 1/2/2000, so that, it does not get included to 1/1 report\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"lotId\",\"type\":\"string\",\"doc\":\"LotNumber.\"},{\"name\":\"lotOrder\",\"type\":\"long\",\"doc\":\"LotOrder. this is used to effectively handle ordering logic\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"financialAccount\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccount\",\"doc\":\"Financial Account type.\",\"symbols\":[\"COST\",\"UnrealizedPxNAV\",\"UnrealizedPxPnL\",\"UnrealizedFxNAV\",\"UnrealizedFxPnL\",\"UnrealizedCrossNAV\",\"UnrealizedCrossPnL\",\"RealizedPxPnL\",\"RealizedFxPnL\",\"RealizedCrossPnL\",\"BackoutUnrealizedPxNAV\",\"BackoutUnrealizedPxPnL\",\"BackoutUnrealizedFxNAV\",\"BackoutUnrealizedFxPnL\",\"BackoutUnrealizedCrossNAV\",\"BackoutUnrealizedCrossPnL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccount. Different types of Journal entry types.. ex: Realized PnL, Un-realized PnL\"},{\"name\":\"financialAccountCategory\",\"type\":{\"type\":\"enum\",\"name\":\"FinancialAccountCategory\",\"doc\":\"Fin Account type.\",\"symbols\":[\"NAV\",\"PNL\"],\"type-only\":\"true\"},\"doc\":\"FinancialAccountValueType. Ex: NAV, PnL\"},{\"name\":\"journalAttribute\",\"type\":{\"type\":\"enum\",\"name\":\"JournalAttribute\",\"doc\":\"* Represents the category of journal entry\",\"symbols\":[\"QUANTITY\",\"LOCAL\",\"BOOK\"],\"type-only\":\"true\"},\"doc\":\"Category. Ex: Local, Book, Quantity..\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"amount\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"Amount.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"type-only\":\"true\"}},\"doc\":\"List of journals\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276574986,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "FixReferenceDataValue",
				"description": "(\"FixReferenceData Value Schema\" )*",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 33,
			"timestamp": 1529421178077,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 33,
						"name": "MASTER",
						"schemaMetadataName": "FixReferenceDataValue",
						"description": "'MASTER' branch for schema metadata 'FixReferenceDataValue'",
						"timestamp": 1529421178078
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 416,
							"schemaMetadataId": 33,
							"name": "FixReferenceDataValue",
							"description": "(\"FixReferenceData Value Schema\" )*",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"FixReferenceDataValue\",\"namespace\":\"firm.transaction.referencedata.fix\",\"doc\":\"(\\\"FixReferenceData Value Schema\\\" )*\",\"fields\":[{\"name\":\"outputs\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"TemporalOutput\",\"doc\":\"Temporal output\",\"fields\":[{\"name\":\"output\",\"type\":{\"type\":\"map\",\"values\":\"string\"}},{\"name\":\"dateRange\",\"type\":{\"type\":\"record\",\"name\":\"DateRange\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"startDate\",\"type\":[{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"null\"],\"doc\":\"StartDate for date range\"},{\"name\":\"endDate\",\"type\":[\"LocalDate\",\"null\"],\"doc\":\"EndDate for date range\"}],\"logicalType\":\"DateRange\"}},{\"name\":\"knowledgeTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"}}]}},\"doc\":\"Array of TemporalOutput\"}],\"root\":\"true\"}",
							"timestamp": 1530276574390,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "FixReferenceDataKey",
				"description": "(\"FixReferenceData Key Schema\" )*",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 32,
			"timestamp": 1529421177925,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 32,
						"name": "MASTER",
						"schemaMetadataName": "FixReferenceDataKey",
						"description": "'MASTER' branch for schema metadata 'FixReferenceDataKey'",
						"timestamp": 1529421177926
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 415,
							"schemaMetadataId": 32,
							"name": "FixReferenceDataKey",
							"description": "(\"FixReferenceData Key Schema\" )*",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"FixReferenceDataKey\",\"namespace\":\"firm.transaction.referencedata.fix\",\"doc\":\"(\\\"FixReferenceData Key Schema\\\" )*\",\"fields\":[{\"name\":\"inputs\",\"type\":{\"type\":\"map\",\"values\":\"string\"},\"doc\":\"* Inputs for Fix Referenece data\"}],\"root\":\"true\"}",
							"timestamp": 1530276573198,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "FirmTransactionValue",
				"description": "Firm transaction",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 31,
			"timestamp": 1529421177512,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 31,
						"name": "MASTER",
						"schemaMetadataName": "FirmTransactionValue",
						"description": "'MASTER' branch for schema metadata 'FirmTransactionValue'",
						"timestamp": 1529421177513
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 414,
							"schemaMetadataId": 31,
							"name": "FirmTransactionValue",
							"description": "Firm transaction",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"FirmTransactionValue\",\"namespace\":\"firm.transaction\",\"doc\":\"Firm transaction\",\"fields\":[{\"name\":\"currentVersionType\",\"type\":\"string\",\"doc\":\"* has the type of the transaction's current version (example EquityFillV0, FXFillV0)\"},{\"name\":\"currentVersion\",\"type\":[{\"type\":\"record\",\"name\":\"EquityFillV0\",\"fields\":[{\"name\":\"version\",\"type\":\"int\",\"doc\":\"* transaction version\"},{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"* securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":\"string\",\"doc\":\"* some tag used to mark position in the book \r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":\"string\",\"doc\":\"* custodian id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"fillSide\",\"type\":{\"type\":\"enum\",\"name\":\"FillSide\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* side\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price in security's position currency\"},{\"name\":\"cost\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* cost of the transaction\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc. \r\n\t\t * the key represents the type of the charge\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":\"string\",\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":\"string\",\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"int\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"localPrice\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":\"string\",\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":\"string\",\"doc\":\"* didvider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"}],\"type-only\":\"true\"},{\"type\":\"record\",\"name\":\"FXFillV0\",\"fields\":[{\"name\":\"version\",\"type\":\"int\",\"doc\":\"* transaction version\"},{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"* securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":\"string\",\"doc\":\"* some tag used to mark position in the book \r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":\"TransactionStatus\",\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":\"string\",\"doc\":\"* custodian id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* execution time\"},{\"name\":\"fillSide\",\"type\":\"FillSide\",\"doc\":\"* side\"},{\"name\":\"transactionDirection\",\"type\":\"TransactionDirection\",\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"cost\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* cost of the transaction\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":\"string\",\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":\"string\",\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"int\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"}],\"type-only\":\"true\"},{\"type\":\"record\",\"name\":\"BondFillV0\",\"fields\":[{\"name\":\"version\",\"type\":\"int\",\"doc\":\"* transaction version\"},{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"* securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":\"string\",\"doc\":\"* some tag used to mark position in the book \r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":\"TransactionStatus\",\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":\"string\",\"doc\":\"* custodian id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* execution time\"},{\"name\":\"fillSide\",\"type\":\"FillSide\",\"doc\":\"* side\"},{\"name\":\"transactionDirection\",\"type\":\"TransactionDirection\",\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"cost\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* cost of the transaction\"},{\"name\":\"settlementCost\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* cost of the transaction including accrual\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":\"string\",\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":\"string\",\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"int\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"}],\"type-only\":\"true\"},{\"type\":\"record\",\"name\":\"CorporateActionV0\",\"fields\":[{\"name\":\"version\",\"type\":\"int\",\"doc\":\"* transaction version\"},{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"* securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":\"string\",\"doc\":\"* some tag used to mark position in the book \r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":\"TransactionStatus\",\"doc\":\"* transaction status\"},{\"name\":\"transactionDirection\",\"type\":\"TransactionDirection\",\"doc\":\"* direction of the transaction\"},{\"name\":\"exDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* ex date for corporate action\"},{\"name\":\"custodianId\",\"type\":\"string\",\"doc\":\"* custodian id\"},{\"name\":\"corporateActionType\",\"type\":\"string\",\"doc\":\"* actual, street known type of the corporate action (cash dividend, split, etc.). \r\n\t\t * two values which coming from panorama are Legacy.XDIV and Legacy.REOR\"},{\"name\":\"dividendAmount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* dividend amount (could be negative if position was short)\"},{\"name\":\"dividendcurrency\",\"type\":\"string\",\"doc\":\"* currency for dividend amount\"},{\"name\":\"quantity\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* quantity of shares we are getting (could be negative if position was short)\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":\"Charge\"},\"doc\":\"* the map of various charges associated with the corporate action: fee, tax, etc. \r\n\t\t * the key represents the name of the charge\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":\"string\",\"doc\":\"* user id who booked the transaction\"}],\"type-only\":\"true\"},{\"type\":\"record\",\"name\":\"RepoV0\",\"fields\":[{\"name\":\"version\",\"type\":\"int\",\"doc\":\"* transaction version\"},{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"* securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":\"string\",\"doc\":\"* some tag used to mark position in the book \r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":\"TransactionStatus\",\"doc\":\"* transaction status\"},{\"name\":\"transactionDirection\",\"type\":\"TransactionDirection\",\"doc\":\"* direction of the transaction\"},{\"name\":\"custodianId\",\"type\":\"string\",\"doc\":\"* custodian id\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":\"string\",\"doc\":\"* user id who booked the transaction\"}],\"type-only\":\"true\"}],\"doc\":\"* current version of the transaction\"},{\"name\":\"priorVersionType\",\"type\":[\"string\",\"null\"],\"doc\":\"* has the type of the transaction's prior version (example EquityFillV0, FXFillV0), if null it means there is no current version\"},{\"name\":\"priorVersion\",\"type\":[\"EquityFillV0\",\"FXFillV0\",\"BondFillV0\",\"CorporateActionV0\",\"RepoV0\",\"null\"],\"doc\":\"* prior version of the transaction, if null there is no prior version\"},{\"name\":\"panoramaTimestamp\",\"type\":[\"long\",\"null\"],\"doc\":\"* legacy panorama timestamp to accommodate smooth transition from panorama to new structure\",\"default\":null},{\"name\":\"panoramaInstrumentId\",\"type\":[\"long\",\"null\"],\"doc\":\"* legacy panorama instrument id to accommodate smooth transition from panorama to new structure\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276571129,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "FirmTransactionKey",
				"description": "The key which uniquely identifies Firm transaction",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 30,
			"timestamp": 1529421177337,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 30,
						"name": "MASTER",
						"schemaMetadataName": "FirmTransactionKey",
						"description": "'MASTER' branch for schema metadata 'FirmTransactionKey'",
						"timestamp": 1529421177338
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 413,
							"schemaMetadataId": 30,
							"name": "FirmTransactionKey",
							"description": "The key which uniquely identifies Firm transaction",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"FirmTransactionKey\",\"namespace\":\"firm.transaction\",\"doc\":\"The key which uniquely identifies Firm transaction\",\"fields\":[{\"name\":\"firmTransactionSource\",\"type\":\"string\",\"doc\":\"* source which uniquely identifies transaction (formerly known in pano as TradeSource or WTDataSource)\"},{\"name\":\"firmTransactionId\",\"type\":\"string\",\"doc\":\"* firm transaction id (formerly known in pano as TradeID or WTOriginalID)\"},{\"name\":\"version\",\"type\":\"int\",\"doc\":\"* version of the Firm transaction\"}],\"root\":\"true\"}",
							"timestamp": 1530276569916,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "ErrorValue",
				"description": "Error details",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 29,
			"timestamp": 1529421177181,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 29,
						"name": "MASTER",
						"schemaMetadataName": "ErrorValue",
						"description": "'MASTER' branch for schema metadata 'ErrorValue'",
						"timestamp": 1529421177182
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 412,
							"schemaMetadataId": 29,
							"name": "ErrorValue",
							"description": "Error details",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"ErrorValue\",\"namespace\":\"firm.error\",\"doc\":\"Error details\",\"fields\":[{\"name\":\"errorMessage\",\"type\":\"string\",\"doc\":\"Error message - Reason for the error *\"},{\"name\":\"exception\",\"type\":[\"string\",\"null\"],\"doc\":\"Error exception text *\"},{\"name\":\"errorTimeStamp\",\"type\":\"string\",\"doc\":\"Error timestamp in the format of yyyy-MM-dd HH:mm:ss in UTC timezone *\"}],\"root\":\"true\"}",
							"timestamp": 1530276569118,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "ErrorOutput",
				"description": "This will be output from Camunda, which will be published to the topic, and the app that waits for the action can consume ErrorOutputV0 and process  *",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 28,
			"timestamp": 1529421177010,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 28,
						"name": "MASTER",
						"schemaMetadataName": "ErrorOutput",
						"description": "'MASTER' branch for schema metadata 'ErrorOutput'",
						"timestamp": 1529421177011
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 411,
							"schemaMetadataId": 28,
							"name": "ErrorOutput",
							"description": "This will be output from Camunda, which will be published to the topic, and the app that waits for the action can consume ErrorOutputV0 and process  *",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"ErrorOutput\",\"namespace\":\"firm.error.management\",\"doc\":\"This will be output from Camunda, which will be published to the topic, and the app that waits for the action can consume ErrorOutputV0 and process  *\",\"fields\":[{\"name\":\"errorInput\",\"type\":{\"type\":\"record\",\"name\":\"ErrorInput\",\"doc\":\"Error that occurred in any system should be created as ErrorInputV0. ErrorInputV0 will be published to Kafka, which in turn Camunda will consume it as its Input to process with Workflow\",\"fields\":[{\"name\":\"dateOccured\",\"type\":{\"type\":\"long\",\"java-class\":\"org.joda.time.DateTime\"},\"doc\":\"Error occurred date time\"},{\"name\":\"errorType\",\"type\":\"string\",\"doc\":\"Denotes error type\"},{\"name\":\"projectName\",\"type\":\"string\",\"doc\":\"Denotes project name the error occurred\"},{\"name\":\"appName\",\"type\":\"string\",\"doc\":\"Denotes App name the error occurred\"},{\"name\":\"errorMessage\",\"type\":\"string\",\"doc\":\"Denotes error message\"},{\"name\":\"errorTrace\",\"type\":\"string\",\"doc\":\"Denotes error trace\"},{\"name\":\"errorContent\",\"type\":\"string\",\"doc\":\"Denotes error content\"},{\"name\":\"errorObject\",\"type\":\"string\",\"doc\":\"Denotes error object\"}],\"root\":\"true\"},\"doc\":\"Denotes error input that actually occurred and posted in Camunda\"},{\"name\":\"userId\",\"type\":\"string\",\"doc\":\"Denotes user id who processed the errorInput in Camunda\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"symbols\":[\"Ignore\",\"Reprocess\"]},\"doc\":\"Denotes action which is result of Error Input(in camunda) that affecting the application\"},{\"name\":\"actionDate\",\"type\":\"long\",\"doc\":\"Denotes action result date\"}],\"root\":\"true\"}",
							"timestamp": 1530276567912,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "ErrorKey",
				"description": "Key to identify an Auditable Error",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 27,
			"timestamp": 1529421176816,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 27,
						"name": "MASTER",
						"schemaMetadataName": "ErrorKey",
						"description": "'MASTER' branch for schema metadata 'ErrorKey'",
						"timestamp": 1529421176817
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 410,
							"schemaMetadataId": 27,
							"name": "ErrorKey",
							"description": "Key to identify an Auditable Error",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"ErrorKey\",\"namespace\":\"firm.error\",\"doc\":\"Key to identify an Auditable Error\",\"fields\":[{\"name\":\"errorCode\",\"type\":\"string\",\"doc\":\"A unique name for the error produced *\"},{\"name\":\"errorNamespace\",\"type\":\"string\",\"doc\":\"The namespace for which the error code is associated *\"}],\"root\":\"true\"}",
							"timestamp": 1530276567362,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "ErrorInput",
				"description": "Error that occurred in any system should be created as ErrorInputV0. ErrorInputV0 will be published to Kafka, which in turn Camunda will consume it as its Input to process with Workflow",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 26,
			"timestamp": 1529421176659,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 26,
						"name": "MASTER",
						"schemaMetadataName": "ErrorInput",
						"description": "'MASTER' branch for schema metadata 'ErrorInput'",
						"timestamp": 1529421176659
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 409,
							"schemaMetadataId": 26,
							"name": "ErrorInput",
							"description": "Error that occurred in any system should be created as ErrorInputV0. ErrorInputV0 will be published to Kafka, which in turn Camunda will consume it as its Input to process with Workflow",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"ErrorInput\",\"namespace\":\"firm.error.management\",\"doc\":\"Error that occurred in any system should be created as ErrorInputV0. ErrorInputV0 will be published to Kafka, which in turn Camunda will consume it as its Input to process with Workflow\",\"fields\":[{\"name\":\"dateOccured\",\"type\":{\"type\":\"long\",\"java-class\":\"org.joda.time.DateTime\"},\"doc\":\"Error occurred date time\"},{\"name\":\"errorType\",\"type\":\"string\",\"doc\":\"Denotes error type\"},{\"name\":\"projectName\",\"type\":\"string\",\"doc\":\"Denotes project name the error occurred\"},{\"name\":\"appName\",\"type\":\"string\",\"doc\":\"Denotes App name the error occurred\"},{\"name\":\"errorMessage\",\"type\":\"string\",\"doc\":\"Denotes error message\"},{\"name\":\"errorTrace\",\"type\":\"string\",\"doc\":\"Denotes error trace\"},{\"name\":\"errorContent\",\"type\":\"string\",\"doc\":\"Denotes error content\"},{\"name\":\"errorObject\",\"type\":\"string\",\"doc\":\"Denotes error object\"}],\"root\":\"true\"}",
							"timestamp": 1530276565257,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EnhancedKey",
				"description": "Key Schema for normalized messages",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 25,
			"timestamp": 1529421176495,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 25,
						"name": "MASTER",
						"schemaMetadataName": "EnhancedKey",
						"description": "'MASTER' branch for schema metadata 'EnhancedKey'",
						"timestamp": 1529421176496
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 408,
							"schemaMetadataId": 25,
							"name": "EnhancedKey",
							"description": "Key Schema for normalized messages",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EnhancedKey\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"Key Schema for normalized messages\",\"fields\":[{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"The name of our gateway which brought the message in\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"The name of the session inside gateway\"},{\"name\":\"seqStartDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"The date when sequence has been started\"},{\"name\":\"seqNum\",\"type\":\"long\",\"doc\":\"Sequence number inside the given seqStartDateTime\"}],\"root\":\"true\"}",
							"timestamp": 1530276564584,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EnhancedFX",
				"description": "* Schema for EnhancedFX",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 24,
			"timestamp": 1529421176149,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 24,
						"name": "MASTER",
						"schemaMetadataName": "EnhancedFX",
						"description": "'MASTER' branch for schema metadata 'EnhancedFX'",
						"timestamp": 1529421176149
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 407,
							"schemaMetadataId": 24,
							"name": "EnhancedFX",
							"description": "* Schema for EnhancedFX",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"EnhancedFX\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedFX\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"forwardDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"the forward date for FX forward contract\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayRecievedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"currency1Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency1Amount\"},{\"name\":\"currency2Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency2Amount\"},{\"name\":\"fxCalc\",\"type\":\"string\",\"doc\":\"* value would be M or D\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null},{\"name\":\"transactionId\",\"type\":[\"null\",\"string\"],\"doc\":\"transaction id\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276563294,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 406,
							"schemaMetadataId": 24,
							"name": "EnhancedFX",
							"description": "* Schema for EnhancedFX",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EnhancedFX\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedFX\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"forwardDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"the forward date for FX forward contract\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* fixing date\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayRecievedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"currency1Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency1Amount\"},{\"name\":\"currency2Amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* currency2Amount\"},{\"name\":\"fxCalc\",\"type\":\"string\",\"doc\":\"* value would be M or D\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276563139,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EnhancedErrorValue",
				"description": "\"Value Schema for normalized error message\"",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 23,
			"timestamp": 1529421175853,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 23,
						"name": "MASTER",
						"schemaMetadataName": "EnhancedErrorValue",
						"description": "'MASTER' branch for schema metadata 'EnhancedErrorValue'",
						"timestamp": 1529421175854
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 405,
							"schemaMetadataId": 23,
							"name": "EnhancedErrorValue",
							"description": "\"Value Schema for normalized error message\"",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EnhancedErrorValue\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"\\\"Value Schema for normalized error message\\\"\",\"fields\":[{\"name\":\"errorDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"Datetime when this error occorred\"},{\"name\":\"normalizedKeyType\",\"type\":[\"string\",\"null\"],\"doc\":\"The type of the normalizedKeyType key\",\"default\":null},{\"name\":\"normalizedKey\",\"type\":[{\"type\":\"record\",\"name\":\"NormalizedKey\",\"namespace\":\"firm.transaction.normalized\",\"doc\":\"Key Schema for normalized messages\",\"fields\":[{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"The name of our gateway which brought the message in\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"The name of the session inside gateway\"},{\"name\":\"seqStartDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"The date when sequence has been started\"},{\"name\":\"seqNum\",\"type\":\"long\",\"doc\":\"Sequence number inside the given seqStartDateTime\"}],\"root\":\"true\"},\"null\"],\"doc\":\"NormalizedKey key\",\"default\":null},{\"name\":\"normalizedValueType\",\"type\":[\"string\",\"null\"],\"doc\":\"The type of the normalizedValueType\",\"default\":null},{\"name\":\"normalizedValue\",\"type\":[{\"type\":\"record\",\"name\":\"NormalizedFX\",\"namespace\":\"firm.transaction.normalized.fx\",\"doc\":\"*\\\"Schema for a FX Spot, Forward and NDF message received from FIX, file, manual entry, etc.\\\"\",\"fields\":[{\"name\":\"rawId\",\"type\":[{\"type\":\"record\",\"name\":\"RawFIXKey\",\"namespace\":\"firm.transaction.raw.fix\",\"doc\":\"This key makes sure that all the FIX messages from a particular FIX session are always available on the same partition\",\"fields\":[{\"name\":\"sendingDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"The date when the messages was sent to us by the broker's fix engine\"},{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw FIX message originated\r\n        There is a possibility that two FIX engines can have the same SessionID configured and this field would\r\n        be the differentiator\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"Identifier for the FIX sessionID.\"},{\"name\":\"msgSeqNum\",\"type\":\"int\",\"doc\":\"MsgSeqNum generated by the FIX engine for his session\"}],\"root\":\"true\"},\"null\"],\"doc\":\"* Id of raw message. It is used to make sure that raw message is not processed twice\",\"default\":null},{\"name\":\"rawType\",\"type\":[\"string\",\"null\"],\"doc\":\"* The type of the raw id (example RawFIXKeyType)\",\"default\":null},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\",\"default\":null},{\"name\":\"symbol\",\"type\":\"string\",\"doc\":\"* The name of the currency pair where the first currency is the base currency. The two elements (base and terms) must be three-character ISO codes for a currency.\r\n*  For example, GBP/USD\"},{\"name\":\"account\",\"type\":\"string\",\"doc\":\"* The value received from the source system to identify the Firm's trading account identifier which can be linked to PM, firm accounting structure and etc.\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Strategy\",\"default\":null},{\"name\":\"fillStatus\",\"type\":\"string\",\"doc\":\"* Status of transaction NEW, AMEND, CANCEL\"},{\"name\":\"tradeDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Trade date of the transaction\",\"default\":null},{\"name\":\"custodian\",\"type\":[\"string\",\"null\"],\"doc\":\"* The value received from the source system to identify the Firms code for custodian account at PB to which fill was applied\r\n* {Optional}\",\"default\":null},{\"name\":\"broker\",\"type\":[\"string\",\"null\"],\"doc\":\"* The value received from the source system to identify the Firms code for execution broker id\",\"default\":null},{\"name\":\"line\",\"type\":[\"string\",\"null\"],\"doc\":\"* Execution line\",\"default\":null},{\"name\":\"settlementDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Settlement date if provided by the broker\",\"default\":null},{\"name\":\"fixingDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Fixing date\",\"default\":null},{\"name\":\"executionTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* Execution time set by market place\"},{\"name\":\"fillSide\",\"type\":\"string\",\"doc\":\"* Side of transaction BUY, SELL\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* Quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* Price\"},{\"name\":\"spotRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* Spot rate\",\"default\":null},{\"name\":\"forwardPoints\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* Forward Rate\",\"default\":null},{\"name\":\"senderCompId\",\"type\":\"string\",\"doc\":\"* Sender company id\"},{\"name\":\"targetCompId\",\"type\":\"string\",\"doc\":\"* Target company id\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* User id\",\"default\":null},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"* Deal currency\",\"default\":null},{\"name\":\"fillId\",\"type\":\"string\",\"doc\":\"* ExecID or ExecRefId based on whether the fill is new or cancel/correct\"},{\"name\":\"sequenceIdGeneratorType\",\"type\":[\"string\",\"null\"],\"doc\":\"* Type of sequence generator (STANDARD, SERVICE_BUREAU)\",\"default\":\"STANDARD\"},{\"name\":\"senderSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX SenderSubID\",\"default\":null},{\"name\":\"targetSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX TargetSubID\",\"default\":null},{\"name\":\"onBehalfOfCompId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX OnBehalfOfCompID\",\"default\":null},{\"name\":\"onBehalfOfSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX OnBehalfOfSubID\",\"default\":null},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"System time\",\"default\":null},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"populated from raw knowledge time\",\"default\":null},{\"name\":\"fillRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"Fill Reference Id(execRefId or tradeReportRefID)\",\"default\":null}],\"root\":\"true\"},{\"type\":\"record\",\"name\":\"NormalizedEquity\",\"namespace\":\"firm.transaction.normalized.equity\",\"doc\":\"*\\\"Schema for a FX Spot, Forward and NDF message received from FIX, file, manual entry, etc.\\\"\",\"fields\":[{\"name\":\"rawId\",\"type\":[\"firm.transaction.raw.fix.RawFIXKey\",{\"type\":\"record\",\"name\":\"RawNeovestKey\",\"namespace\":\"firm.transaction.raw.neovest\",\"doc\":\"This key makes sure that all the Neovest messages from a particular FIX session are always available on the same partition\",\"fields\":[{\"name\":\"sendingDateTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"The dateTime when the messages was sent to us by the broker's fix engine, this is not the time when Neovest is sending us\"},{\"name\":\"gatewayName\",\"type\":\"string\",\"doc\":\"Identifier for the Gateway. This is to uniquely identify which gateway this Raw message originated\"},{\"name\":\"sessionId\",\"type\":\"string\",\"doc\":\"sessionId for messages from Neovest will be in the format SenderCompID++TargetCompID. This is because, a single instance of Neovest can receive messages from session with same sessionId, but different FIX engines. The combination has proved to be unique across FIX engines.\"},{\"name\":\"neoSysSeqNum\",\"type\":\"int\",\"doc\":\"neoSysSeqNum, Neovest generates a sysSeqNum which is sequential for all the messages that it publishes to allobridge user, it doesnot use the FIX MsgSeqNum\"}],\"root\":\"true\"}],\"doc\":\"* Id of raw message. It is used to make sure that raw message is not processed twice\",\"default\":null},{\"name\":\"rawType\",\"type\":[\"string\",\"null\"],\"doc\":\"* The type of the raw id (example RawFIXKeyType)\",\"default\":null},{\"name\":\"inputMessageId\",\"type\":[\"firm.type.MessageIdWithWorkId\",\"null\"],\"doc\":\"* Message id with work id\",\"default\":null},{\"name\":\"symbol\",\"type\":\"string\",\"doc\":\"* The name of the currency pair where the first currency is the base currency. The two elements (base and terms) must be three-character ISO codes for a currency.\r\n*  For example, GBP/USD\"},{\"name\":\"account\",\"type\":\"string\",\"doc\":\"* The value received from the source system to identify the Firm's trading account identifier which can be linked to PM, firm accounting structure and etc.\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* Strategy\",\"default\":null},{\"name\":\"fillStatus\",\"type\":\"string\",\"doc\":\"* Status of transaction LIVE, CANCELED\"},{\"name\":\"tradeDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Trade date of the transaction\",\"default\":null},{\"name\":\"custodian\",\"type\":[\"string\",\"null\"],\"doc\":\"* The value received from the source system to identify the Firms code for custodian account at PB to which fill was applied\r\n* {Optional}\",\"default\":null},{\"name\":\"broker\",\"type\":[\"string\",\"null\"],\"doc\":\"* The value received from the source system to identify the Firms code for execution broker id\",\"default\":null},{\"name\":\"line\",\"type\":[\"string\",\"null\"],\"doc\":\"* Execution line\",\"default\":null},{\"name\":\"settlementDate\",\"type\":[\"firm.type.LocalDate\",\"null\"],\"doc\":\"* Settlement date if provided by the broker\",\"default\":null},{\"name\":\"executionTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* Execution time set by market place\"},{\"name\":\"fillSide\",\"type\":\"string\",\"doc\":\"* Side of transaction BUY, SELL\"},{\"name\":\"quantity\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* Quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* Price\"},{\"name\":\"senderCompId\",\"type\":\"string\",\"doc\":\"* Sender company id\"},{\"name\":\"targetCompId\",\"type\":\"string\",\"doc\":\"* Target company id\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* User id\",\"default\":null},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"* Deal currency\",\"default\":null},{\"name\":\"fillId\",\"type\":\"string\",\"doc\":\"* ExecID or ExecRefId based on whether the fill is new or cancel/correct\"},{\"name\":\"sequenceIdGeneratorType\",\"type\":[\"string\",\"null\"],\"doc\":\"* Type of sequence generator (STANDARD, SERVICE_BUREAU)\",\"default\":null},{\"name\":\"senderSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX SenderSubID\",\"default\":null},{\"name\":\"targetSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX TargetSubID\",\"default\":null},{\"name\":\"onBehalfOfCompId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX OnBehalfOfCompID\",\"default\":null},{\"name\":\"onBehalfOfSubId\",\"type\":[\"string\",\"null\"],\"doc\":\"* FIX OnBehalfOfSubID\",\"default\":null},{\"name\":\"swapIdentifier\",\"type\":[\"string\",\"null\"],\"doc\":\"* Field to identify if the current transaction is for a swap execution and if so a straight swap or a dollarized swap. \r\n* A value SWP indicates a straight swap, USW will indicate dolarized and CFD indicate contract for difference. If the value is null, it indicates cash.\",\"default\":null},{\"name\":\"fillRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"Fill Reference Id(execRefId or tradeReportRefID)\",\"default\":null},{\"name\":\"idSource\",\"type\":\"string\",\"doc\":\"*IDSource to identify the Symbol type (RIC, BBG, Exchange etc.,) for enhancer to be able to *lookup the appropriate Security Lookup Caches.\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"System time\",\"default\":null},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"populated from raw knowledge time\",\"default\":null},{\"name\":\"settlCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"Settlement Currency for dollarized swaps\"},{\"name\":\"settlCurrFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"Settlement Currency FxRateCalc for dollarized swaps\"},{\"name\":\"settlCurrFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Settlement Currency FxRate for dollarized swaps\"}],\"root\":\"true\"},\"null\"],\"doc\":\"Normalized value\",\"default\":null},{\"name\":\"inputMessageId\",\"type\":[\"firm.type.MessageIdWithWorkId\",\"null\"],\"doc\":\"Message id with work id\",\"default\":null},{\"name\":\"errorType\",\"type\":\"string\",\"doc\":\"The common well known identifier associated with error flow\"},{\"name\":\"errorMessage\",\"type\":\"string\",\"doc\":\"Reason why this rawFIXValue was an error\"},{\"name\":\"errorTrace\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Trace of the Error\"},{\"name\":\"tempContext\",\"type\":{\"type\":\"map\",\"values\":\"string\"},\"doc\":\"* map ccy1,ccy2,forwardDate keys with values\"}],\"root\":\"true\"}",
							"timestamp": 1530276562382,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EnhancedEquity",
				"description": "* Schema for EnhancedEquity",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 22,
			"timestamp": 1529421175500,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 22,
						"name": "MASTER",
						"schemaMetadataName": "EnhancedEquity",
						"description": "'MASTER' branch for schema metadata 'EnhancedEquity'",
						"timestamp": 1529421175501
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 404,
							"schemaMetadataId": 22,
							"name": "EnhancedEquity",
							"description": "* Schema for EnhancedEquity",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"EnhancedEquity\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedEquity\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayReceivedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc.\r\n\t\t * the key represents the type of the charge\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"* divider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"},{\"name\":\"transactionId\",\"type\":[\"null\",\"string\"],\"doc\":\"transaction id\",\"default\":null}],\"root\":\"true\"}",
							"timestamp": 1530276561129,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 403,
							"schemaMetadataId": 22,
							"name": "EnhancedEquity",
							"description": "* Schema for EnhancedEquity",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EnhancedEquity\",\"namespace\":\"firm.transaction.enhanced\",\"doc\":\"* Schema for EnhancedEquity\",\"fields\":[{\"name\":\"securityId\",\"type\":\"string\",\"doc\":\"securityId unique point 72 id which identifies investment\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"id which identifies the portfolio manager book (also known as TradingArea, TradingAreaID)\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"* some tag used to mark position in the book\r\n\t\t * (for discretionary it used to be the main marker then it was replaced with groups and bets, for quants it is still the main mark to split position into different strategy)\"},{\"name\":\"transactionStatus\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionStatus\",\"namespace\":\"firm.transaction\",\"doc\":\"* transaction has been canceled\",\"symbols\":[\"LIVE\",\"CANCELED\"],\"type-only\":\"true\"},\"doc\":\"* transaction status\"},{\"name\":\"tradeDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* the date when trade was executed, in most cases derived from the execution time provided by the broker\"},{\"name\":\"custodianId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian id\"},{\"name\":\"custodianAccount\",\"type\":[\"string\",\"null\"],\"doc\":\"*  our account at custodian\"},{\"name\":\"custodianAccountId\",\"type\":[\"string\",\"null\"],\"doc\":\"* custodian Account id\"},{\"name\":\"executionBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"operationalBrokerId\",\"type\":\"string\",\"doc\":\"* execution broker id\"},{\"name\":\"settlementDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the date when trade should be settled\"},{\"name\":\"executionTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":\"LocalDate\",\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"* execution time\"},{\"name\":\"action\",\"type\":{\"type\":\"enum\",\"name\":\"Action\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the side of the fill from Point 72 point of view\",\"symbols\":[\"BUY\",\"SELL\",\"SHORT\"],\"type-only\":\"true\"},\"doc\":\"* action – Buy (B), Sell (S), Short (H)\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"* direction of the transaction\"},{\"name\":\"quantity\",\"type\":{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"doc\":\"* quantity\"},{\"name\":\"price\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* price\"},{\"name\":\"grossNotional\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* gross notional of the transaction not including charges\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"* currency for price and cost (position currency)\"},{\"name\":\"knowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* system clock set by the process at creation of the instance\"},{\"name\":\"normalizedKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message\"},{\"name\":\"rawKnowledgeTime\",\"type\":\"firm.type.LocalDateTime\",\"doc\":\"* populated from normalized message fixGatewayReceivedTime\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* effective date of the transaction for equities it would be a trade date\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"* the applied knowledge date - used to be position date\"},{\"name\":\"userId\",\"type\":[\"string\",\"null\"],\"doc\":\"* user id who booked the transaction\"},{\"name\":\"executionTraderId\",\"type\":[\"string\",\"null\"],\"doc\":\"* execution trader id. in most cases it should be the same as user id and only different when transaction is booked by ops on behave of the trader\"},{\"name\":\"executionServiceType\",\"type\":\"string\",\"doc\":\"* the code of execution service provided by execution broker (DMA, DESK, ALGO, etc.). it used to calculate commission\"},{\"name\":\"eventId\",\"type\":{\"type\":\"record\",\"name\":\"EventId\",\"namespace\":\"firm.transaction\",\"doc\":\"Represents the combination of ids which uniquely identifies the event for sequencing and versioning\",\"fields\":[{\"name\":\"source\",\"type\":\"string\",\"doc\":\"Event source FIXFXALLDC, .... Set by enhancer based on reference data\"},{\"name\":\"sequenceId\",\"type\":\"string\",\"doc\":\"id need for sequencing, comes from ExecID + Account + ... and set by enhancer\"},{\"name\":\"sequenceRefId\",\"type\":[\"string\",\"null\"],\"doc\":\"ref id need for sequencing, comes from ExecRefID + Account + ... and set by enhancer\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"set by Enhancer as default equal to sequenceId and can be changed by sequencer to capture the sequenceId of parent.parent.parent...\"},{\"name\":\"eventDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"date set by Enhancer - in most cases it is a trade date\"}],\"type-only\":\"true\"},\"doc\":\"eventId used by sequencer\"},{\"name\":\"inputMessageId\",\"type\":[{\"type\":\"record\",\"name\":\"MessageIdWithWorkId\",\"namespace\":\"firm.type\",\"doc\":\"* Combination of message id and work id\",\"fields\":[{\"name\":\"messageId\",\"type\":{\"type\":\"record\",\"name\":\"MessageId\",\"doc\":\"* Combination of topic, partition and offset which uniquely identifies message on any kafka topic\",\"fields\":[{\"name\":\"topic\",\"type\":\"string\",\"doc\":\"* Topic name\"},{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"* Partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"*\"}],\"type-only\":\"true\"},\"doc\":\"* MessageId\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"* WorkId\"}],\"type-only\":\"true\"},\"null\"],\"doc\":\"* Message id with work id\"},{\"name\":\"charges\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"doc\":\"* the map of various charges: commission, SEC fee, tax, etc.\r\n\t\t * the key represents the type of the charge\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* price in local currency. it is different from price for all dollarized swaps, etc\"},{\"name\":\"localCurrency\",\"type\":[\"string\",\"null\"],\"doc\":\"* local currency. it is different from currency for all dollarized swaps, etc\"},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* rate used to convert localPrice into price\"},{\"name\":\"settlementFxRateCalc\",\"type\":[\"string\",\"null\"],\"doc\":\"* divider or multiplier to tell us if price = localPrice * settlementFxRate or  price = localPrice / settlementFxRate\"}],\"root\":\"true\"}",
							"timestamp": 1530276560576,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODPrice",
				"description": "EOD Price mark.",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 21,
			"timestamp": 1529421175240,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 21,
						"name": "MASTER",
						"schemaMetadataName": "EODPrice",
						"description": "'MASTER' branch for schema metadata 'EODPrice'",
						"timestamp": 1529421175241
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 402,
							"schemaMetadataId": 21,
							"name": "EODPrice",
							"description": "EOD Price mark.",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODPrice\",\"namespace\":\"firm.journal\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"underlyerPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerPrice - Price of the underlyer. For DollarizedSwap, this would be tbe price of the underlyer\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276559910,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 401,
							"schemaMetadataId": 21,
							"name": "EODPrice",
							"description": "EOD Price mark.",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODPrice\",\"namespace\":\"firm.journal\",\"doc\":\"EOD Price mark.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"price\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"EOD Price.\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276559634,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODPMPositionPriceErrorKey",
				"description": "Error of an EOD price of the position in position currency",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 20,
			"timestamp": 1529421175070,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 20,
						"name": "MASTER",
						"schemaMetadataName": "EODPMPositionPriceErrorKey",
						"description": "'MASTER' branch for schema metadata 'EODPMPositionPriceErrorKey'",
						"timestamp": 1529421175070
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 400,
							"schemaMetadataId": 20,
							"name": "EODPMPositionPriceErrorKey",
							"description": "Error of an EOD price of the position in position currency",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODPMPositionPriceErrorKey\",\"namespace\":\"firm.pnl\",\"doc\":\"Error of an EOD price of the position in position currency\",\"fields\":[{\"name\":\"positionId\",\"type\":\"string\",\"doc\":\"* positionId\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* bookId\"},{\"name\":\"strategyId\",\"type\":\"string\",\"doc\":\"* strategyId\"},{\"name\":\"positionDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* positionDate\"}],\"root\":\"true\"}",
							"timestamp": 1530276559370,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODPMPositionPriceError",
				"description": "Error of an EOD price of the position in position currency",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 19,
			"timestamp": 1529421174894,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 19,
						"name": "MASTER",
						"schemaMetadataName": "EODPMPositionPriceError",
						"description": "'MASTER' branch for schema metadata 'EODPMPositionPriceError'",
						"timestamp": 1529421174895
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 399,
							"schemaMetadataId": 19,
							"name": "EODPMPositionPriceError",
							"description": "Error of an EOD price of the position in position currency",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODPMPositionPriceError\",\"namespace\":\"firm.pnl\",\"doc\":\"Error of an EOD price of the position in position currency\",\"fields\":[{\"name\":\"openingPrice\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"* openingPrice\"},{\"name\":\"closingPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* closingPrice\"},{\"name\":\"reason\",\"type\":\"string\",\"doc\":\"* error reason\"}],\"root\":\"true\"}",
							"timestamp": 1530276558159,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODPMPositionPrice",
				"description": "EOD price of the position in position currency",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 18,
			"timestamp": 1529421174724,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 18,
						"name": "MASTER",
						"schemaMetadataName": "EODPMPositionPrice",
						"description": "'MASTER' branch for schema metadata 'EODPMPositionPrice'",
						"timestamp": 1529421174726
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 398,
							"schemaMetadataId": 18,
							"name": "EODPMPositionPrice",
							"description": "EOD price of the position in position currency",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODPMPositionPrice\",\"namespace\":\"firm.pnl\",\"doc\":\"EOD price of the position in position currency\",\"fields\":[{\"name\":\"positionId\",\"type\":[\"string\",\"null\"],\"doc\":\"* positionId\"},{\"name\":\"openingPrice\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"* openingPrice\"},{\"name\":\"closingPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* closingPrice\"}],\"root\":\"true\"}",
							"timestamp": 1530276557349,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODPMPositionFXRateErrorKey",
				"description": "Error of an EOD fx rate of the position in position currency",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 17,
			"timestamp": 1529421174557,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 17,
						"name": "MASTER",
						"schemaMetadataName": "EODPMPositionFXRateErrorKey",
						"description": "'MASTER' branch for schema metadata 'EODPMPositionFXRateErrorKey'",
						"timestamp": 1529421174558
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 397,
							"schemaMetadataId": 17,
							"name": "EODPMPositionFXRateErrorKey",
							"description": "Error of an EOD fx rate of the position in position currency",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODPMPositionFXRateErrorKey\",\"namespace\":\"firm.pnl\",\"doc\":\"Error of an EOD fx rate of the position in position currency\",\"fields\":[{\"name\":\"positionId\",\"type\":\"string\",\"doc\":\"* positionId\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"* bookId\"},{\"name\":\"strategyId\",\"type\":\"string\",\"doc\":\"* strategyId\"},{\"name\":\"positionDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* positionDate\"}],\"root\":\"true\"}",
							"timestamp": 1530276556689,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODPMPositionFXRateError",
				"description": "Error of an EOD price of the position in position currency",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 16,
			"timestamp": 1529421174342,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 16,
						"name": "MASTER",
						"schemaMetadataName": "EODPMPositionFXRateError",
						"description": "'MASTER' branch for schema metadata 'EODPMPositionFXRateError'",
						"timestamp": 1529421174343
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 396,
							"schemaMetadataId": 16,
							"name": "EODPMPositionFXRateError",
							"description": "Error of an EOD price of the position in position currency",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODPMPositionFXRateError\",\"namespace\":\"firm.pnl\",\"doc\":\"Error of an EOD price of the position in position currency\",\"fields\":[{\"name\":\"openingRate\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"* openingPrice\"},{\"name\":\"closingRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* closingPrice\"},{\"name\":\"reason\",\"type\":\"string\",\"doc\":\"* error reason\"}],\"root\":\"true\"}",
							"timestamp": 1530276555637,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODPMPositionFXRate",
				"description": "EOD fx rates between position currency and portfolio currency [USD]. It is used in USD PnL = 1000 EUR PnL * 1 / Rate",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 15,
			"timestamp": 1529421174151,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 15,
						"name": "MASTER",
						"schemaMetadataName": "EODPMPositionFXRate",
						"description": "'MASTER' branch for schema metadata 'EODPMPositionFXRate'",
						"timestamp": 1529421174152
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 395,
							"schemaMetadataId": 15,
							"name": "EODPMPositionFXRate",
							"description": "EOD fx rates between position currency and portfolio currency [USD]. It is used in USD PnL = 1000 EUR PnL * 1 / Rate",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODPMPositionFXRate\",\"namespace\":\"firm.pnl\",\"doc\":\"EOD fx rates between position currency and portfolio currency [USD]. It is used in USD PnL = 1000 EUR PnL * 1 / Rate\",\"fields\":[{\"name\":\"positionId\",\"type\":[\"string\",\"null\"],\"doc\":\"* positionId\"},{\"name\":\"openingRate\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"* openingRate\"},{\"name\":\"closingRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"* closingRate\"}],\"root\":\"true\"}",
							"timestamp": 1530276555223,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "EODFXRate",
				"description": "EOD FX Rate",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 14,
			"timestamp": 1529421173846,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 14,
						"name": "MASTER",
						"schemaMetadataName": "EODFXRate",
						"description": "'MASTER' branch for schema metadata 'EODFXRate'",
						"timestamp": 1529421173847
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 394,
							"schemaMetadataId": 14,
							"name": "EODFXRate",
							"description": "EOD FX Rate",
							"version": 3,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODFXRate\",\"namespace\":\"firm.journal\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"underlyerRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerRate - for dollarizedSwap, this rate would be the underlyers fx rate\",\"default\":null},{\"name\":\"forwardRates\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"EODFXForwardRate\",\"doc\":\"EOD FX Forward Rate\",\"fields\":[{\"name\":\"forwardCurrency\",\"type\":\"string\",\"doc\":\"Forward Currency\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. Business date. Input from Event data\"},{\"name\":\"forwardDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"ForwardDate. Input from Event data\"},{\"name\":\"forwardRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Forward. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}},\"null\"],\"doc\":\"ForwardRates - One or Two forward rates for the FX forward\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276553753,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 393,
							"schemaMetadataId": 14,
							"name": "EODFXRate",
							"description": "EOD FX Rate",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODFXRate\",\"namespace\":\"firm.journal\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"underlyerRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"underlyerRate - for dollarizedSwap, this rate would be the underlyers fx rate\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276553633,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 392,
							"schemaMetadataId": 14,
							"name": "EODFXRate",
							"description": "EOD FX Rate",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"EODFXRate\",\"namespace\":\"firm.journal\",\"doc\":\"EOD FX Rate\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"currency\",\"type\":[\"string\",\"null\"],\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"rate\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276553360,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "DroolsRule",
				"description": "Drools rule state stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 13,
			"timestamp": 1529421173672,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 13,
						"name": "MASTER",
						"schemaMetadataName": "DroolsRule",
						"description": "'MASTER' branch for schema metadata 'DroolsRule'",
						"timestamp": 1529421173673
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 390,
							"schemaMetadataId": 13,
							"name": "DroolsRule",
							"description": "Drools rule state stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"DroolsRule\",\"namespace\":\"firm.drools\",\"doc\":\"Drools rule state stream\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"id of the set of drools rules\"},{\"name\":\"category\",\"type\":\"string\",\"doc\":\"the category of the rule e.g. Commisions, Fees, Taxs etc.\"},{\"name\":\"rules\",\"type\":\"string\",\"doc\":\"the set of rules to evaluate\"},{\"name\":\"domains\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"the list of domains in namespace+record format that are associated with this rule set\"},{\"name\":\"attributes\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"the list of attributes that are associated with this rule set\"}],\"root\":\"true\"}",
							"timestamp": 1530276551259,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "CurrencyByCode",
				"description": "Currency Lookup Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 12,
			"timestamp": 1529421173484,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 12,
						"name": "MASTER",
						"schemaMetadataName": "CurrencyByCode",
						"description": "'MASTER' branch for schema metadata 'CurrencyByCode'",
						"timestamp": 1529421173485
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 389,
							"schemaMetadataId": 12,
							"name": "CurrencyByCode",
							"description": "Currency Lookup Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"CurrencyByCode\",\"namespace\":\"firm.currency\",\"doc\":\"Currency Lookup Stream\",\"fields\":[{\"name\":\"code\",\"type\":\"string\",\"doc\":\"Currency Code history\"},{\"name\":\"idHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"EffectiveString\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"value\",\"type\":[\"string\",\"null\"]}],\"logicalType\":\"EffectiveString\"}},\"doc\":\"id history\"}],\"root\":\"true\"}",
							"timestamp": 1530276550169,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "Currency",
				"description": "Currency State Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 11,
			"timestamp": 1529421173293,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 11,
						"name": "MASTER",
						"schemaMetadataName": "Currency",
						"description": "'MASTER' branch for schema metadata 'Currency'",
						"timestamp": 1529421173294
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 388,
							"schemaMetadataId": 11,
							"name": "Currency",
							"description": "Currency State Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"Currency\",\"namespace\":\"firm.currency\",\"doc\":\"Currency State Stream\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"Currency ID\"},{\"name\":\"codeHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"EffectiveString\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"value\",\"type\":[\"string\",\"null\"]}],\"logicalType\":\"EffectiveString\"}},\"doc\":\"code history\"},{\"name\":\"descriptionHistory\",\"type\":{\"type\":\"array\",\"items\":\"firm.type.EffectiveString\"},\"doc\":\"description history\"},{\"name\":\"numericCodeHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"EffectiveInt\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"value\",\"type\":\"int\",\"default\":0}],\"logicalType\":\"EffectiveInt\"}},\"doc\":\"numeric code history\"},{\"name\":\"minorUnitTypeHistory\",\"type\":{\"type\":\"array\",\"items\":\"firm.type.EffectiveInt\"},\"doc\":\"decimal places of the currency history\"}],\"root\":\"true\"}",
							"timestamp": 1530276548959,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "CheckpointValue",
				"description": "The key of checkpoint topic",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 10,
			"timestamp": 1529421173106,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 10,
						"name": "MASTER",
						"schemaMetadataName": "CheckpointValue",
						"description": "'MASTER' branch for schema metadata 'CheckpointValue'",
						"timestamp": 1529421173107
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 387,
							"schemaMetadataId": 10,
							"name": "CheckpointValue",
							"description": "The key of checkpoint topic",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"CheckpointValue\",\"namespace\":\"firm.transaction.checkpoint\",\"doc\":\"The key of checkpoint topic\",\"fields\":[{\"name\":\"dateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"Datetime when checkpoint was captured\"},{\"name\":\"outputOffsetMaps\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"OffsetMap\",\"namespace\":\"firm.type\",\"doc\":\"* Offset Map\",\"fields\":[{\"name\":\"partitions\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"* An array of partitions\"},{\"name\":\"offsets\",\"type\":{\"type\":\"array\",\"items\":\"long\"},\"doc\":\"* An array of segments\"}],\"logicalType\":\"OffsetMap\"}},\"doc\":\"output offset maps\"},{\"name\":\"inputOffsetList\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"PartitionOffsetWorkId\",\"doc\":\"Partition, offset, work id\",\"fields\":[{\"name\":\"partition\",\"type\":\"int\",\"doc\":\"partition\"},{\"name\":\"offset\",\"type\":\"long\",\"doc\":\"offset\"},{\"name\":\"workId\",\"type\":\"long\",\"doc\":\"workId\"}]}},\"doc\":\"input offset list\"},{\"name\":\"inputPending\",\"type\":\"int\",\"doc\":\"number of input messages pending for checkpoint\"},{\"name\":\"outputPending\",\"type\":{\"type\":\"map\",\"values\":\"int\"},\"doc\":\"number of output messages pending for checkpoint\"}],\"root\":\"true\"}",
							"timestamp": 1530276547990,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "CheckpointKey",
				"description": "The key of checkpoint topic",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 9,
			"timestamp": 1529421172934,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 9,
						"name": "MASTER",
						"schemaMetadataName": "CheckpointKey",
						"description": "'MASTER' branch for schema metadata 'CheckpointKey'",
						"timestamp": 1529421172934
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 386,
							"schemaMetadataId": 9,
							"name": "CheckpointKey",
							"description": "The key of checkpoint topic",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"CheckpointKey\",\"namespace\":\"firm.transaction.checkpoint\",\"doc\":\"The key of checkpoint topic\",\"fields\":[{\"name\":\"inputTopicName\",\"type\":\"string\",\"doc\":\"Input topic name\"}],\"root\":\"true\"}",
							"timestamp": 1530276547050,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "BookSetByCode",
				"description": "BookSet Lookup Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 8,
			"timestamp": 1529421172756,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 8,
						"name": "MASTER",
						"schemaMetadataName": "BookSetByCode",
						"description": "'MASTER' branch for schema metadata 'BookSetByCode'",
						"timestamp": 1529421172757
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 385,
							"schemaMetadataId": 8,
							"name": "BookSetByCode",
							"description": "BookSet Lookup Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"BookSetByCode\",\"namespace\":\"firm.book\",\"doc\":\"BookSet Lookup Stream\",\"fields\":[{\"name\":\"code\",\"type\":\"string\",\"doc\":\"book code\"},{\"name\":\"idHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"EffectiveString\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"value\",\"type\":[\"string\",\"null\"]}],\"logicalType\":\"EffectiveString\"}},\"doc\":\"ID history for this code\"}],\"root\":\"true\"}",
							"timestamp": 1530276546086,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "BookSet",
				"description": "BookSet State Stream",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 7,
			"timestamp": 1529421172567,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 7,
						"name": "MASTER",
						"schemaMetadataName": "BookSet",
						"description": "'MASTER' branch for schema metadata 'BookSet'",
						"timestamp": 1529421172568
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 384,
							"schemaMetadataId": 7,
							"name": "BookSet",
							"description": "BookSet State Stream",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"BookSet\",\"namespace\":\"firm.book\",\"doc\":\"BookSet State Stream\",\"fields\":[{\"name\":\"id\",\"type\":\"string\",\"doc\":\"id of the book\"},{\"name\":\"namespaceIdHistory\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"EffectiveString\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"effectiveStartDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"effectiveEndDate\",\"type\":{\"type\":\"int\",\"logicalType\":\"date\"},\"default\":0},{\"name\":\"value\",\"type\":[\"string\",\"null\"]}],\"logicalType\":\"EffectiveString\"}},\"doc\":\"namespace history\"},{\"name\":\"codeHistory\",\"type\":{\"type\":\"array\",\"items\":\"firm.type.EffectiveString\"},\"doc\":\"code history\"},{\"name\":\"descriptionHistory\",\"type\":{\"type\":\"array\",\"items\":\"firm.type.EffectiveString\"},\"doc\":\"description history\"},{\"name\":\"childBookHistory\",\"type\":{\"type\":\"array\",\"items\":\"firm.type.EffectiveString\"},\"doc\":\"child book history\"}],\"root\":\"true\"}",
							"timestamp": 1530276545268,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		},
		{
			"schemaMetadata": {
				"type": "avro",
				"schemaGroup": "Point72",
				"name": "AggregatedTransaction",
				"description": "Journal Entry Schema.",
				"compatibility": "BACKWARD",
				"validationLevel": "ALL",
				"evolve": true
			},
			"id": 6,
			"timestamp": 1529421172131,
			"schemaBranches": [
				{
					"schemaBranch": {
						"id": 6,
						"name": "MASTER",
						"schemaMetadataName": "AggregatedTransaction",
						"description": "'MASTER' branch for schema metadata 'AggregatedTransaction'",
						"timestamp": 1529421172132
					},
					"rootSchemaVersion": null,
					"schemaVersionInfos": [
						{
							"id": 467,
							"schemaMetadataId": 6,
							"name": "AggregatedTransaction",
							"description": "Journal Entry Schema.",
							"version": 3,
							"schemaText": "{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"custodianAccountId\",\"type\":[\"null\",\"string\"],\"doc\":\"CustodianAccountId. Input from Event data\",\"default\":null},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Local Price. For Dollarized Swaps, VWAP calculated based on the Input from Event data (or) Mark-Price\",\"default\":null},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Settlement FX Rate. For Dollarized Swaps\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530540066848,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 383,
							"schemaMetadataId": 6,
							"name": "AggregatedTransaction",
							"description": "Journal Entry Schema.",
							"version": 2,
							"schemaText": "{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"localPrice\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Local Price. For Dollarized Swaps, VWAP calculated based on the Input from Event data (or) Mark-Price\",\"default\":null},{\"name\":\"settlementFxRate\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Settlement FX Rate. For Dollarized Swaps\",\"default\":null},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276544275,
							"stateId": 5,
							"mergeInfo": null
						},
						{
							"id": 382,
							"schemaMetadataId": 6,
							"name": "AggregatedTransaction",
							"description": "Journal Entry Schema.",
							"version": 1,
							"schemaText": "{\"type\":\"record\",\"name\":\"AggregatedTransaction\",\"namespace\":\"firm.journal\",\"doc\":\"Journal Entry Schema.\",\"fields\":[{\"name\":\"sequenceNumber\",\"type\":\"long\",\"doc\":\"Sequence number used to detect duplicates. Offset number from transaction topic\"},{\"name\":\"knowledgeDateTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalDateTime\",\"namespace\":\"firm.type\",\"fields\":[{\"name\":\"localDate\",\"type\":{\"type\":\"record\",\"name\":\"LocalDate\",\"doc\":\"Type firm.type.LocalDate should be used when you want to serialize & deserialize a java.time.LocalDate instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized (Date is converted into yyyyMMdd and treated as an in on the wire) with the below schema.\r\n\t *  The firm.schema.common.avro.Record has the required api that convert the java.time.LocalDate to and from this schema.\",\"fields\":[{\"name\":\"value\",\"type\":\"int\",\"doc\":\"localDate in yyyyMMdd format.\",\"default\":19000101}],\"logicalType\":\"LocalDate\"},\"doc\":\"* LocalDate\",\"default\":null},{\"name\":\"localTime\",\"type\":{\"type\":\"record\",\"name\":\"LocalTime\",\"fields\":[{\"name\":\"hourMinuteSecond\",\"type\":\"int\",\"doc\":\"LocalTime.hourMinuteSecond (hhmmss)\",\"default\":0},{\"name\":\"nano\",\"type\":\"int\",\"doc\":\"LocalTime.nano\",\"default\":0}],\"logicalType\":\"LocalTime\"},\"doc\":\"* LocalTime\",\"default\":null}],\"logicalType\":\"LocalDateTime\"},\"doc\":\"KnowledgeDate. Input from Event data\"},{\"name\":\"effectiveDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"EffectiveDate. This is tradeDate. Input from Event data\"},{\"name\":\"appliedKnowledgeDate\",\"type\":\"firm.type.LocalDate\",\"doc\":\"AppliedKnowledgeDate. Input from Event data\"},{\"name\":\"eventId\",\"type\":\"string\",\"doc\":\"EventId. Input from Event data\"},{\"name\":\"transactionId\",\"type\":\"string\",\"doc\":\"TransactionID. Generated & Unique per key [Key is: bookId + strategy + investment + effectiveDate + transactionType]\"},{\"name\":\"aggregatedTransactionId\",\"type\":\"string\",\"doc\":\"ID. Generated by aggregated transaction system\"},{\"name\":\"bookId\",\"type\":\"string\",\"doc\":\"BookId. Ex: COHE, COHM. Input from Event data\"},{\"name\":\"strategy\",\"type\":[\"string\",\"null\"],\"doc\":\"Strategy. Input from Event data\"},{\"name\":\"investmentId\",\"type\":\"string\",\"doc\":\"Investment. Input from Event data\"},{\"name\":\"operationsBrokerId\",\"type\":[\"string\",\"null\"],\"doc\":\"ExecutingBroker. Input from Event data\"},{\"name\":\"transactionDirection\",\"type\":{\"type\":\"enum\",\"name\":\"TransactionDirection\",\"namespace\":\"firm.transaction\",\"doc\":\"* Represents the direction of the transaction from Point 72 point of view when it is applied to the position. Assuming position has short and long bucket. Decrement would be applied to short bucket. Increment to long.\",\"symbols\":[\"INCREMENT\",\"DECREMENT\"],\"type-only\":\"true\"},\"doc\":\"TransactionDirection. Ex: INCREMENT, DECREMENT.. Input from Event data\"},{\"name\":\"quantity\",\"type\":[{\"type\":\"record\",\"name\":\"BigDecimal\",\"namespace\":\"firm.type\",\"doc\":\"Type firm.type.BigDecimal should be used when you want to serialize & deserialize a java.math.BigDecimal instance using avro.\r\n\t *  On the wire that data is serialzied/deserialized with the below schema.The firm.schema.common.avro.Record has the required\r\n\t *  api that convert the java.math.BigDecimal to and from this schema.\",\"fields\":[{\"name\":\"scale\",\"type\":\"int\",\"doc\":\"number of decimal places\",\"default\":0},{\"name\":\"listOfInt\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"array of ints\",\"default\":0}],\"logicalType\":\"BigDecimal\"},\"null\"],\"doc\":\"Quantity. Calculated based on the Input from Event data\"},{\"name\":\"price\",\"type\":[\"firm.type.BigDecimal\",\"null\"],\"doc\":\"Price. Weighted Average Price calculated based on the Input from Event data (or) Mark-Price\"},{\"name\":\"charges\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"Charge\",\"namespace\":\"firm.transaction\",\"fields\":[{\"name\":\"ruleId\",\"type\":\"long\",\"doc\":\"* CFT rule id associated with this charge, rule id 0 is a legacy calculation\"},{\"name\":\"rateType\",\"type\":\"string\",\"doc\":\"* the rate type we paid B - basis points, P - cents per share, A - amount\"},{\"name\":\"rate\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* rate used in charge calculation formula\"},{\"name\":\"amount\",\"type\":\"firm.type.BigDecimal\",\"doc\":\"* amount associated with the charge\"}],\"type-only\":\"true\"}},\"null\"],\"doc\":\"the map of various charges: commission, SEC fee, tax, etc. the key represents the type of the charge. Input from Event data\"},{\"name\":\"currency\",\"type\":\"string\",\"doc\":\"Currency. Ex: GBP, JPY. Input from Event data\"},{\"name\":\"pricingFactor\",\"type\":[\"null\",\"firm.type.BigDecimal\"],\"doc\":\"Pricing Factor. Input from Security Master. TODO: how to handle the changes to the value? *\"},{\"name\":\"scalingFactor\",\"type\":[\"null\",\"firm.type.BigDecimal\"],\"doc\":\"Scaling Factor. Input from Security master. TODO: how to handle the changes to the value? *\"},{\"name\":\"timestamp\",\"type\":[{\"type\":\"map\",\"values\":{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}},\"null\"],\"doc\":\"Map of processing timestamp. Ex: [\\\"TransactionReceived\\\", System.currentTimeMillis()]\"}],\"root\":\"true\"}",
							"timestamp": 1530276543724,
							"stateId": 5,
							"mergeInfo": null
						}
					]
				}
			],
			"serDesInfos": []
		}
	]
}